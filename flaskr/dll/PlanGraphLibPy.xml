<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PlanGraphLibPy</name>
    </assembly>
    <members>
        <member name="T:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino">
            <summary>
            Class <c>DrawGraphInRhino</c> collects functions to visualize a <c>Graph</c> in the Rhino viewport.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino.DrawGraph(PlanGraphLibPy.The_graph.Graph,System.Double,System.Collections.Generic.List{Rhino.Geometry.Circle}@,System.Collections.Generic.List{Rhino.Geometry.Line}@,System.Collections.Generic.List{System.String})">
            <summary>
            This method returns the nodes as <c>Rhino.Geometry.Circle</c> and the edges as <c>Rhino.Geometry.Line</c>, 
            that can be visualized in Rhino.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="radius">The radius of the nodes.</param>
            <param name="DrawnNodes">The list with nodes as <c>Rhino.Geometry.Circle</c>.</param>
            <param name="DrawnEdges">The list with edges as <c>Rhino.Geometry.Line</c>.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <returns>
            Returns true when finished.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino.DrawCircularGraph(PlanGraphLibPy.The_graph.Graph,System.Double,System.Collections.Generic.List{System.String},Rhino.Geometry.Point3d,System.Double)">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed in one big circle.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="radius">The radius of the nodes.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="center">The center of the big circle on which the nodes are placed.</param>
            <param name="bigradius">The radius of the big circle on which the nodes are placed.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino.DrawRandomPlacedGraph(PlanGraphLibPy.The_graph.Graph,System.Double,System.Collections.Generic.List{System.String},Rhino.Geometry.Curve,System.Int32)">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            randomly placed inside a predefined perimeter.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="radius">The radius of the nodes.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="perimeter">The perimeter in which the nodes are placed.</param>
            <param name="seed">The seed.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino.DrawForceDirectedGraph(PlanGraphLibPy.The_graph.Graph,System.Double,System.Collections.Generic.List{System.String},System.Double,System.Double)">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed pulled to each other if an edge is present and pushed away from each other when no edge between them is present.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="radius">The radius of the nodes.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="attrFactor">The factor of attraction when an edge is present between two nodes.</param>
            <param name="repulFactor">The factor of repulsion when no edge is present between two nodes.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino.DrawPointGraph(PlanGraphLibPy.The_graph.Graph,System.Double,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Rhino.Geometry.Point3d})">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed according to a predefined list of points.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="radius">The radius of the nodes.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="points">The points on which the nodes are placed.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Drawing_in_Rhino.DrawTreeInRhino">
            <summary>
            Class <c>DrawTreeInRhino</c> collects functions to visualize a <c>Tree</c> in the Rhino viewport.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawTreeInRhino.DrawTree(PlanGraphLibPy.The_tree.Tree,Rhino.Geometry.Point3d,System.Collections.Generic.List{Rhino.Geometry.Circle}@,System.Collections.Generic.List{Rhino.Geometry.Brep}@,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{Rhino.Geometry.Line}@,System.Collections.Generic.List{Rhino.Geometry.Curve}@,System.Double,System.Double,System.String)">
            <summary>
            This method returns the nodes as <c>Rhino.Geometry.Circle</c> and the edges as <c>Rhino.Geometry.Line</c>, 
            that can be visualized in Rhino.
            </summary>
            <param name="tree">The tree that needs to be visualized.</param>
            <param name="rootPoint">The point where the root node will be placed.</param>
            <param name="DrawnNodes">The list with nodes as <c>Rhino.Geometry.Circle</c>.</param>
            <param name="DrawnNodesCopy">The list with nodes as <c>Rhino.Geometry.Brep</c>.</param>
            <param name="DrawnNodeLabels">The list with nodes as <c>Rhino.Geometry.Circle</c>.</param>
            <param name="DrawnEdges">The list with edges as <c>Rhino.Geometry.Line</c>.</param>
            <param name="DrawnSiblingEdges">The list with edges between two nodes on the same level, as <c>Rhino.Geometry.Curve</c>.</param>
            <param name="leafDistance">The distance between the leaf nodes.</param>
            <param name="branchDistance">The distance between the nodes on a different level.</param>
            <param name="areaDynProp">The name of the dynamic property of the <c>Node</c> where the area is stored.</param>
        </member>
        <member name="T:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan">
            <summary>
            Class <c>DrawGraphInRhino_Plan</c> collects functions to visualize a <c>Graph_Plan</c> in the Rhino viewport.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan.DrawGraph(PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{Rhino.Geometry.Circle}@,System.Collections.Generic.List{Rhino.Geometry.Line}@,System.Collections.Generic.List{Rhino.Geometry.Circle}@,System.Collections.Generic.List{System.String})">
            <summary>
            This method returns the nodes as <c>Rhino.Geometry.Circle</c> and the edges as <c>Rhino.Geometry.Line</c>, 
            that can be visualized in Rhino.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="DrawnNodes">The list with nodes as <c>Rhino.Geometry.Circle</c>.</param>
            <param name="DrawnEdges">The list with edges as <c>Rhino.Geometry.Line</c>.</param>
            <param name="DrawnExtEdges">The list with edges as <c>Rhino.Geometry.Circle</c> around the nodes that are connected to the exterior.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <returns>
            Returns true when finished.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan.DrawCircularGraph(PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.String},Rhino.Geometry.Point3d,System.Double)">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed in one big circle.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="center">The center of the big circle on which the nodes are placed.</param>
            <param name="bigradius">The radius of the big circle on which the nodes are placed.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan.DrawPlanGraph(PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.String})">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed inside the space boundary of the correct <c>Node_Space</c>.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan.DrawRandomPlacedGraph(PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.String},Rhino.Geometry.Curve,System.Int32)">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            randomly placed inside a predefined perimeter.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="perimeter">The perimeter in which the nodes are placed.</param>
            <param name="seed">The seed.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan.DrawForceDirectedGraph(PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.String},System.Double,System.Double)">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed pulled to each other if an edge is present and pushed away from each other when no edge between them is present.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="attrFactor">The factor of attraction when an edge is present between two nodes.</param>
            <param name="repulFactor">The factor of repulsion when no edge is present between two nodes.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan.DrawPointGraph(PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Rhino.Geometry.Point3d})">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed according to a predefined list of points.
            </summary>
            <param name="graph">The graph that needs to be visualized.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="points">The points on which the nodes are placed.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Drawing_in_Rhino.DrawGraphInRhino_Plan.DrawMatchedGraph(PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.String},PlanGraphLibPy.The_graph.Graph_Plan,Grasshopper.Kernel.Data.GH_Structure{Grasshopper.Kernel.Types.GH_Integer})">
            <summary>
            This method returns the <c>Rhino.Geometry</c> elements to visualize the graph in Rhino. In this visualization, the nodes are 
            placed inside the space boundary of the <c>Node_Space</c> to which the node was aligned.
            </summary>
            <param name="graph">The functional graph that needs to be visualized.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when drawing the graph.</param>
            <param name="geometricalGraph">The geometrical graph in which the functional graph will be visualized.</param>
            <param name="nodePairs">The alignment as node pairs.</param>
            <returns>
            Returns the rhino geometry.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.GeneralFunctions">
            <summary>
            Class <c>GeneralFunctions</c> collects some general, handy functions.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.GeneralFunctions.giveSomeColors(System.Int32,System.Int32)">
            <summary>
            This method returns some random colors as <c>System.Drawing.Color</c>.
            </summary>
            <param name="number">The number of colors that are needed.</param>
            <param name="seed">The seed.</param>
            <returns>
            Returns a list of colors.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.GeneralFunctions.fak(System.Int32)">
            <summary>
            This method calculates the factorial n! of a number n.
            </summary>
            <param name="number">The number n.</param>
            <returns>
            Returns the factorial n! of the number.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Geometry.Point">
            <summary>
            Class <c>Point</c> constructs a 3D point with X, Y and Z coordinates.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Geometry.Point.X">
            <summary>
            Property <c>X</c> represents the X coordinate of this <c>Point</c> as double.
            </summary>
            <example>For example:
            <code>
            Point p = new Point(3, 2, 1);
            Console.WriteLine(p.X);
            // The example displays the following output:
            //    3
            </code>
            </example>
            <value>
            Property <c>X</c> represents the X coordinate of this <c>Point</c> as double.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Geometry.Point.Y">
            <summary>
            Property <c>Y</c> represents the Y coordinate of this <c>Point</c> as double.
            </summary>
            <example>For example:
            <code>
            Point p = new Point(3, 2, 1);
            Console.WriteLine(p.Y);
            // The example displays the following output:
            //    2
            </code>
            </example>
            <value>
            Property <c>Y</c> represents the Y coordinate of this <c>Point</c> as double.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Geometry.Point.Z">
            <summary>
            Property <c>Z</c> represents the Z coordinate of this <c>Point</c> as double.
            </summary>
            <example>For example:
            <code>
            Point p = new Point(3, 2, 1);
            Console.WriteLine(p.Z);
            // The example displays the following output:
            //    1
            </code>
            </example>
            <value>
            Property <c>Z</c> represents the Z coordinate of this <c>Point</c> as double.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Point.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            This constructor initializes a new <c>Point</c>.
            </summary>
            <example>For example:
            <code>
            Point p = new Point(3, 2, 1);
            Console.WriteLine("X: "+p.X+"; Y: "+p.Y+"; Z: "+p.Z);
            // The example displays the following output:
            //    X: 3; Y: 2; Z: 1
            </code>
            </example>
            <param name="x">The X coordinate of this <c>Point</c> as double.</param>
            <param name="y">The Y coordinate of this <c>Point</c> as double.</param>
            <param name="z">The Z coordinate of this <c>Point</c> as double.</param>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Point.EqualTo(PlanGraphLibPy.Geometry.Point,System.Double)">
            <summary>
            This method checks if another <c>Point</c> has the same coordinates as this <c>Point</c>.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(3, 2, 1);
            Point p2 = new Point(3.0, 2.001, 1.0);
            Console.WriteLine(p1.EqualTo(p2, 0.0));
            Console.WriteLine(p1.EqualTo(p2, 0.1));
            // The example displays the following output:
            //    False
            //    True
            </code>
            </example>
            <param name="otherPoint">The other <c>Point</c>.</param>
            <param name="tolerance">The tolerance as double.</param>
            <returns>
            Returns true if the two points have the same coordinates.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Point.DistanceTo(PlanGraphLibPy.Geometry.Point)">
            <summary>
            This method calculates the distance from this <c>Point</c> to another <c>Point</c>.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(3, 2, 1);
            Point p2 = new Point(1, 2, 3);
            Console.WriteLine(p1.DistanceTo(p2));
            // The example displays the following output:
            //    2,8284271247461903
            </code>
            </example>
            <param name="otherPoint">The other <c>Point</c>.</param>
            <returns>
            Returns distance between the two points.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Geometry.Polyline">
            <summary>
            Class <c>Polyline</c> constructs a polyline as a list of points.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Geometry.Polyline.Points">
            <summary>
            Property <c>Points</c> represents the ordered list of points defining this <c>Polyline</c>.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline pl = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            </code>
            </example>
            <value>
            Property <c>Points</c> represents the ordered list of points defining this <c>Polyline</c>.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Polyline.#ctor(System.Collections.Generic.List{PlanGraphLibPy.Geometry.Point})">
            <summary>
            This constructor initializes a new <c>Polyline</c>.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline pl = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            </code>
            </example>
            <param name="points">The ordered list of points defining this <c>Polyline</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Polyline.IsClosed(System.Double)">
            <summary>
            This method checks if this <c>Polyline</c> is closed.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline pl1 = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4 });
            Polyline pl2 = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            Console.WriteLine(pl1.IsClosed());
            Console.WriteLine(pl2.IsClosed());
            // The example displays the following output:
            //    False
            //    True
            </code>
            </example>
            <param name="tolerance">The tolerance as double.</param>
            <returns>
            Returns true if the <c>Polyline</c> is closed.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Polyline.Area">
            <summary>
            This method calculates the area enclosed by this closed <c>Polyline</c>.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline pl1 = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4 });
            Polyline pl2 = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            Console.WriteLine(pl1.Area());
            Console.WriteLine(pl2.Area());
            // The example displays the following output:
            //    0
            //    25
            </code>
            </example>
            <returns>
            Returns the area enclosed by the <c>Polyline</c> if it is a closed polyline; else 0.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Polyline.Centroid">
            <summary>
            This method calculates the centroid of this <c>Polyline</c>.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline pl = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            Point c = pl.Centroid();
            
            Console.WriteLine("X: " + c.X + "; Y: " + c.Y + "; Z: " + c.Z);
            // The example displays the following output:
            //    X: 2,5; Y: 2,5; Z: 0
            </code>
            </example>
            <returns>
            Returns the centroid of this <c>Polyline</c> as <c>Point</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Geometry.Polyline.IsHorizontal(System.Double)">
            <summary>
            This method checks if this <c>Polyline</c> is parallel to the XY plane.
            </summary>
            <example>For example:
            <code>
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0.01);
            Polyline pl = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            Console.WriteLine(pl.IsHorizontal(0));
            Console.WriteLine(pl.IsHorizontal(0.1));
            // The example displays the following output:
            //    False
            //    True
            </code>
            </example>
            <param name="tolerance">The tolerance as double.</param>
            <returns>
            Returns true if the <c>Polyline</c> is horizontal.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter">
            <summary>
            Class <c>FourNodeGraphletOrbitCounter</c> makes it possible to count the orbits of the graphlets with size 4.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.hostGraph">
            <summary>
            Property <c>hostGraph</c> represents the <c>OrcaGraph</c> from which this <c>FourNodeGraphletOrbitCounter</c> was made.
            </summary>
            <value>
            Property <c>hostGraph</c> represents the <c>OrcaGraph</c> from which this <c>FourNodeGraphletOrbitCounter</c> was made.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.n">
            <summary>
            Property <c>n</c> represents the number of nodes in the <c>hostGraph</c>.
            </summary>
            <value>
            Property <c>n</c> represents the number of nodes in the <c>hostGraph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.m">
            <summary>
            Property <c>n</c> represents the number of edges in the <c>hostGraph</c>.
            </summary>
            <value>
            Property <c>n</c> represents the number of edges in the <c>hostGraph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.deg">
            <summary>
            Property <c>deg</c> represents the array of the degrees of the nodes in the <c>hostGraph</c>.
            </summary>
            <value>
            Property <c>deg</c> represents the array of the degrees of the nodes in the <c>hostGraph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.edges">
            <summary>
            Property <c>edges</c> represents the list of edges in the <c>hostGraph</c>.
            </summary>
            <value>
            Property <c>edges</c> represents the list of edges in the <c>hostGraph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.adj">
            <summary>
            Property <c>adj</c> represents the adjacency list of the <c>hostGraph</c>.
            </summary>
            <value>
            Property <c>adj</c> represents the adjacency list of the <c>hostGraph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.inc">
            <summary>
            Property <c>inc</c> represents the incident list of the <c>hostGraph</c>.
            </summary>
            <value>
            Property <c>inc</c> represents the incident list of the <c>hostGraph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.orbit">
            <summary>
            Property <c>orbit</c> represents the orbit count for each node.
            </summary>
            <value>
            Property <c>orbit</c> represents the orbit count for each node.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.#ctor(PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph)">
            <summary>
            This constructor initializes a new <c>FourNodeGraphletOrbitCounter</c> from an <c>OrcaGraph</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            // Construct orbit counter
            FourNodeGraphletOrbitCounter counter = new FourNodeGraphletOrbitCounter(og);
            long[][] orbitcount = counter.count();
            
            foreach (long[] signature in orbitcount)
            {
            	string str = "";
            	foreach(long value in signature)
            	{
            		str += value + " ";
            	}
            	Console.WriteLine(str);
            }
            // The example displays the following output:
            //    3 2 3 0 0 2 0 1 1 0 0 0 0 0 0
            //    2 3 1 0 0 1 1 0 1 0 0 0 0 0 0
            //    2 3 1 0 0 1 1 0 1 0 0 0 0 0 0
            //    2 2 1 0 2 0 0 0 1 0 0 0 0 0 0
            //    1 2 0 0 2 0 1 0 0 0 0 0 0 0 0
            </code>
            </example>
            <param name="orcaGraph">The <c>OrcaGraph</c> from which this <c>FourNodeGraphletOrbitCounter</c> will be made.</param>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.FourNodeGraphletOrbitCounter.count">
            <summary>
            This method calculates the count of the orbits of the graphlets with size 4, i.e. the signature of a node.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            // Construct orbit counter
            FourNodeGraphletOrbitCounter counter = new FourNodeGraphletOrbitCounter(og);
            long[][] orbitcount = counter.count();
            
            foreach (long[] signature in orbitcount)
            {
            	string str = "";
            	foreach(long value in signature)
            	{
            		str += value + " ";
            	}
            	Console.WriteLine(str);
            }
            // The example displays the following output:
            //    3 2 3 0 0 2 0 1 1 0 0 0 0 0 0
            //    2 3 1 0 0 1 1 0 1 0 0 0 0 0 0
            //    2 3 1 0 0 1 1 0 1 0 0 0 0 0 0
            //    2 2 1 0 2 0 0 0 1 0 0 0 0 0 0
            //    1 2 0 0 2 0 1 0 0 0 0 0 0 0 0
            </code>
            </example>
            <returns>
            Returns the signature of each node.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph">
            <summary>
            Class <c>OrcaGraph</c> represents a <c>Graph</c> in another way, with adjacency lists and incidence lists.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.RefGraph">
            <summary>
            Property <c>RefGraph</c> represents the <c>Graph</c> from which this <c>OrcaGraph</c> was made.
            </summary>
            <value>
            Property <c>RefGraph</c> represents the <c>Graph</c> from which this <c>OrcaGraph</c> was made.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.EdgeLabelsToConsider">
            <summary>
            Property <c>EdgeLabelsToConsider</c> represents a list of edge labels that are taken into account to construct 
            this <c>OrcaGraph</c>.
            </summary>
            <value>
            Property <c>EdgeLabelsToConsider</c> represents a list of edge labels that are taken into account to construct 
            this <c>OrcaGraph</c>.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.#ctor(PlanGraphLibPy.The_graph.Graph,System.Collections.Generic.List{System.String})">
            <summary>
            This constructor initializes a new <c>OrcaGraph</c> from a <c>Graph</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            Console.WriteLine("The graph has " + og.getNodesCount() + " nodes.");
            Console.WriteLine("The graph has " + og.getEdgesCount() + " edges.");
            // The example displays the following output:
            //    The graph has 5 nodes.
            //    The graph has 5 edges.
            </code>
            </example>
            <param name="refGraph">The <c>Graph</c> from which this <c>OrcaGraph</c> will be made.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to construct 
            this <c>OrcaGraph</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.getEdgesCount">
            <summary>
            This method returns the number of edges in the <c>OrcaGraph</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            Console.WriteLine("The graph has " + og.getNodesCount() + " nodes.");
            Console.WriteLine("The graph has " + og.getEdgesCount() + " edges.");
            // The example displays the following output:
            //    The graph has 5 nodes.
            //    The graph has 5 edges.
            </code>
            </example>
            <returns>
            Returns the number of edges in this <c>OrcaGraph</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.getNodesCount">
            <summary>
            This method returns the number of nodes in the <c>OrcaGraph</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            Console.WriteLine("The graph has " + og.getNodesCount() + " nodes.");
            Console.WriteLine("The graph has " + og.getEdgesCount() + " edges.");
            // The example displays the following output:
            //    The graph has 5 nodes.
            //    The graph has 5 edges.
            </code>
            </example>
            <returns>
            Returns the number of nodes in this <c>OrcaGraph</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.getNodesDegree">
            <summary>
            This method returns an array of degrees of the nodes in the <c>RefGraph</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            int[] nodesdegree = og.getNodesDegree();
            foreach (int degree in nodesdegree)
            {
                Console.WriteLine(degree);
            }
            // The example displays the following output:
            //    3
            //    2
            //    2
            //    2
            //    1
            </code>
            </example>
            <returns>
            Returns the array of degrees of the nodes in the <c>RefGraph</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.getEdges">
            <summary>
            This method returns the <c>Edges</c> of the <c>RefGraph</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            int[] nodesdegree = og.getNodesDegree();
            foreach (int degree in nodesdegree)
            {
                Console.WriteLine(degree);
            }
            // The example displays the following output:
            //    3
            //    2
            //    2
            //    2
            //    1
            </code>
            </example>
            <returns>
            Returns the <c>Edges</c> of the <c>RefGraph</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.getAdjacencyList">
            <summary>
            This method returns an array of adjacencies for each node, in which an adjacency is represented by the 
            index of the adjacent node.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            int[][] adjs = og.getAdjacencyList();
            foreach (int[] adj in adjs)
            {
                string str = "";
                foreach(int value in adj)
                {
                    str += value + " ";
                }
                Console.WriteLine(str);
            }
            // The example displays the following output:
            //    1 2 4
            //    0 3
            //    0 3
            //    1 2
            //    0
            </code>
            </example>
            <returns>
            Returns an array of adjacencies for each node.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.getIncidentList">
            <summary>
            This method returns an array of incidences for each node, in which an incidence is a tuple of an adjacency 
            is represented by the index of the adjacent node and the index of the edge causing the adjacency.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            Tuple&lt;int, int&gt;[][] incs = og.getIncidentList();
            foreach (Tuple&lt;int, int&gt;[] inc in incs)
            {
                string str = "";
                foreach (Tuple&lt;int, int&gt; value in inc)
                {
                    str += "[" + value.Item1 + ", " + value.Item2 + "] ";
                }
                Console.WriteLine(str);
            }
            // The example displays the following output:
            //    [1, 1] [2, 2] [4, 0]
            //    [0, 1] [3, 3]
            //    [0, 2] [3, 4]
            //    [1, 3] [2, 4]
            //    [0, 0]
            </code>
            </example>
            <returns>
            Returns an array of incidences for each node.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Graphlet_degree_vectors.OrcaGraph.printAllPaths(System.Int32,System.Int32)">
            <summary>
            This method finds all valid paths between two nodes as a list of node sequences. A valid path in this case is a path 
            that does not pass through a node more than one time.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct OrcaGraph
            OrcaGraph og = new OrcaGraph(g, g.EdgeLabelsCollection);
            
            Tuple&lt;int, int&gt;[][] incs = og.getIncidentList();
            foreach (Tuple&lt;int, int&gt;[] inc in incs)
            {
                string str = "";
                foreach (Tuple&lt;int, int&gt; value in inc)
                {
                    str += "[" + value.Item1 + ", " + value.Item2 + "] ";
                }
                Console.WriteLine(str);
            }
            // The example displays the following output:
            //    [1, 1] [2, 2] [4, 0]
            //    [0, 1] [3, 3]
            //    [0, 2] [3, 4]
            //    [1, 3] [2, 4]
            //    [0, 0]
            </code>
            </example>
            <param name="s">The index of the node at the start of the path.</param>
            <param name="d">The index of the node at the destination of the path.</param>
            <returns>
            Returns a list of paths. A path is represented by an ordered list of node indices.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.csvGephiToGraph">
            <summary>
            Class <c>csvGephiToGraph</c> makes it possible to convert a csv file to a <c>Graph_Plan</c>.
            The csv files are structured in the same way as the way Gephi exports them.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.csvGephiToGraph.#ctor(System.String,System.String)">
            <summary>
            This constructor initializes a new <c>csvGephiToGraph</c>.
            </summary>
            <example>For example:
            <code>
            
            // The csv of the nodes:
            //    Id,Label,Area,IsExternalArea,HasWindow,HasStairs,IsCirculation
            //    0,Dining room,90000,false,true,false,false
            //    1,Living room,200000,false,true,false,false
            //    2,Kitchen,200000,false,true,false,false
            //    3,Bathroom,70000,false,true,false,false
            //    4,Bedroom,160000,false,true,false,false
            //    5,Bedroom,90000,false,true,false,false
            //    6,Storage,30000,false,false,false,false
            //    7,Corridor,50000,false,false,false,true
            //    8,External area,0,true,false,false,false
            //    
            // The csv of the edges:
            //    Source,Target,Type,Label,Id
            //    0,7,Undirected,Door,7
            //    0,2,Undirected,Air,8
            //    0,8,Undirected,Door,9
            //    1,7,Undirected,Door,10
            //    1,8,Undirected,Door,11
            //    2,6,Undirected,Door,12
            //    2,8,Undirected,Window,13
            //    3,7,Undirected,Door,14
            //    3,8,Undirected,Window,15
            //    4,7,Undirected,Door,16
            //    4,8,Undirected,Window,17
            //    5,7,Undirected,Door,18
            //    5,8,Undirected,Window,19
            //    7,8,Undirected,Door,20
            
            string path_to_csv_nodes = "C:\\path\\to\\gbxml\\file_nodes.csv";
            string path_to_csv_edges = "C:\\path\\to\\gbxml\\file_edges.csv";
            
            csvGephiToGraph converter = new csvGephiToGraph(path_to_csv_nodes, path_to_csv_edges);
            Graph_Plan g = converter.GetPlanGraph();
            
            // Find the path between the dining room and the storage
            List&lt;List&lt;Node&gt;&gt; allPaths = g.AllPaths(g.GetNodes()[0], g.GetNodes()[6], new List&lt;string&gt;() { "door", "air" });
            int pathNr = 1;
            foreach (List&lt;Node&gt; path in allPaths)
            {
            	Console.WriteLine("Path " + pathNr + " exists of the following space sequence:");
            	foreach (Node node in path)
            	{
            		Console.WriteLine("    " + node.NodeLabel);
            	}
            	pathNr++;
            }
            
            // The example displays the following output:
            //    Path 1 exists of the following space sequence:
            //        dining room
            //        kitchen
            //        storage
            </code>
            </example>
            <param name="csvPathNodes">The path to the csv file that contains the node information.</param>
            <param name="csvPathEdges">The path to the csv file that contains the edge information.</param>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.csvGephiToGraph.GetPlanGraph">
            <summary>
            This method returns the new <c>Graph_Plan</c>.
            </summary>
            <example>For example:
            <code>
            
            // The csv of the nodes:
            //    Id,Label,Area,IsExternalArea,HasWindow,HasStairs,IsCirculation
            //    0,Dining room,90000,false,true,false,false
            //    1,Living room,200000,false,true,false,false
            //    2,Kitchen,200000,false,true,false,false
            //    3,Bathroom,70000,false,true,false,false
            //    4,Bedroom,160000,false,true,false,false
            //    5,Bedroom,90000,false,true,false,false
            //    6,Storage,30000,false,false,false,false
            //    7,Corridor,50000,false,false,false,true
            //    8,External area,0,true,false,false,false
            //    
            // The csv of the edges:
            //    Source,Target,Type,Label,Id
            //    0,7,Undirected,Door,7
            //    0,2,Undirected,Air,8
            //    0,8,Undirected,Door,9
            //    1,7,Undirected,Door,10
            //    1,8,Undirected,Door,11
            //    2,6,Undirected,Door,12
            //    2,8,Undirected,Window,13
            //    3,7,Undirected,Door,14
            //    3,8,Undirected,Window,15
            //    4,7,Undirected,Door,16
            //    4,8,Undirected,Window,17
            //    5,7,Undirected,Door,18
            //    5,8,Undirected,Window,19
            //    7,8,Undirected,Door,20
            
            string path_to_csv_nodes = "C:\\path\\to\\gbxml\\file_nodes.csv";
            string path_to_csv_edges = "C:\\path\\to\\gbxml\\file_edges.csv";
            
            csvGephiToGraph converter = new csvGephiToGraph(path_to_csv_nodes, path_to_csv_edges);
            Graph_Plan g = converter.GetPlanGraph();
            
            // Find the path between the dining room and the storage
            List&lt;List&lt;Node&gt;&gt; allPaths = g.AllPaths(g.GetNodes()[0], g.GetNodes()[6], new List&lt;string&gt;() { "door", "air" });
            int pathNr = 1;
            foreach (List&lt;Node&gt; path in allPaths)
            {
            	Console.WriteLine("Path " + pathNr + " exists of the following space sequence:");
            	foreach (Node node in path)
            	{
            		Console.WriteLine("    " + node.NodeLabel);
            	}
            	pathNr++;
            }
            
            // The example displays the following output:
            //    Path 1 exists of the following space sequence:
            //        dining room
            //        kitchen
            //        storage
            </code>
            </example>
            <returns>
            Returns a new <c>Graph_Plan</c> based on the csv files.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlToGraph">
            <summary>
            Class <c>gbxmlToGraph</c> makes it possible to convert a gbXML file to a <c>Graph_Plan</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlToGraph.GbxmlGraph">
            <summary>
            Property <c>GbxmlGraph</c> containing all necessary gbXML information.
            </summary>
            <value>
            Property <c>GbxmlGraph</c> containing all necessary gbXML information.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlToGraph.#ctor(System.String)">
            <summary>
            This constructor initializes a new <c>gbxmlToGraph</c>.
            </summary>
            <example>For example:
            <code>
            string path_to_gbxml = "C:\\path\\to\\gbxml\\file.xml";
            
            gbxmlToGraph converter = new gbxmlToGraph(path_to_gbxml);
            Graph_Plan g = converter.GetPlanGraph(false);
            
            g.GetGraphAsCsv(out List&lt;string&gt; csvNodes, out List&lt;string&gt; csvEdges);
            
            foreach (string info in csvNodes)
            {
            	Console.WriteLine(info);
            }
            Console.WriteLine(" ");
            foreach (string label in g.EdgeLabelsCollection)
            {
            	Console.WriteLine(label);
            }
            // The example displays the following output:
            //    ID,Label,IsOutsideWorld,Area,Name,X,Y,Z,id
            //    0,outside world,true,0,outside world,0,0,0,
            //    1,,false,51.04,5 Space,0,0,0,aim0039
            //    2,,false,49.28,6 Space,0,0,0,aim0099
            //    3,,false,99.76,7 Space,0,0,0,aim0147
            //    4,,false,204.16,8 Space,0,0,0,aim0200
            //    
            //    exteriorwall
            //    interiorwall
            //    nonslidingdoor
            //    interiorfloor
            //    roof
            </code>
            </example>
            <param name="xmlPath">The path to the gbXML file.</param>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlToGraph.GetPlanGraph(System.Boolean)">
            <summary>
            This method puts the information of the <c>gbxmlToGraph</c> in a <c>Graph_Plan</c>.
            </summary>
            <example>For example:
            <code>
            string path_to_gbxml = "C:\\path\\to\\gbxml\\file.xml";
            
            gbxmlToGraph converter = new gbxmlToGraph(path_to_gbxml);
            Graph_Plan g = converter.GetPlanGraph(false);
            
            g.GetGraphAsCsv(out List&lt;string&gt; csvNodes, out List&lt;string&gt; csvEdges);
            
            foreach (string info in csvNodes)
            {
            	Console.WriteLine(info);
            }
            Console.WriteLine(" ");
            foreach (string label in g.EdgeLabelsCollection)
            {
            	Console.WriteLine(label);
            }
            // The example displays the following output:
            //    ID,Label,IsOutsideWorld,Area,Name,X,Y,Z,id
            //    0,outside world,true,0,outside world,0,0,0,
            //    1,,false,51.04,5 Space,0,0,0,aim0039
            //    2,,false,49.28,6 Space,0,0,0,aim0099
            //    3,,false,99.76,7 Space,0,0,0,aim0147
            //    4,,false,204.16,8 Space,0,0,0,aim0200
            //    
            //    exteriorwall
            //    interiorwall
            //    nonslidingdoor
            //    interiorfloor
            //    roof
            </code>
            </example>
            <param name="rhino">True if the library is used in Rhinoceros; false for standalone apps.</param>
            <returns>
            Returns a new <c>Graph_Plan</c> based on the gbXML file.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlGraph">
            <summary>
            Class <c>gbxmlGraph</c> contains <c>gbxmlSpaces</c> as nodes and <c>gbxmlSurfaces</c> as edges.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlGraph.gbxmlSpaces">
            <summary>
            Property <c>gbxmlSpaces</c> represents the spaces present in the gbXML file.
            </summary>
            <value>
            Property <c>gbxmlSpaces</c> represents the spaces present in the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlGraph.gbxmlSurfaces">
            <summary>
            Property <c>gbxmlSurfaces</c> represents the surfaces present in the gbXML file.
            </summary>
            <value>
            Property <c>gbxmlSurfaces</c> represents the surfaces present in the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlGraph.surfaceTypes">
            <summary>
            Property <c>surfaceTypes</c> represents the set of surface types present in the gbXML file.
            </summary>
            <value>
            Property <c>surfaceTypes</c> represents the set of surface types present in the gbXML file.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlGraph.#ctor">
            <summary>
            This constructor initializes a new, empty <c>gbxmlGraph</c>.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlGraph.FindSpaceById(System.String)">
            <summary>
            This method returns the <c>gbxmlSpace</c> with the right <c>id</c>.
            </summary>
            <param name="id">The id of the space that we want to retrieve.</param>
            <returns>
            Returns the <c>gbxmlSpace</c> with the right <c>id</c>; null if not present.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlSpace">
            <summary>
            Class <c>gbxmlSpace</c> contains the <c>id</c>, <c>Area</c> and <c>Name</c> of the imported space object and 
            will be converted to a <c>Node_Space</c> in the <c>Graph_Plan</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSpace.id">
            <summary>
            Property <c>id</c> is directly imported from the gbXML file.
            </summary>
            <value>
            Property <c>id</c> is directly imported from the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSpace.Area">
            <summary>
            Property <c>Area</c> is directly imported from the gbXML file.
            </summary>
            <value>
            Property <c>Area</c> is directly imported from the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSpace.Name">
            <summary>
            Property <c>Name</c> is directly imported from the gbXML file.
            </summary>
            <value>
            Property <c>Name</c> is directly imported from the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSpace.gbxmlSurface_list">
            <summary>
            Property <c>gbxmlSurface_list</c> represents all surfaces enclosing this <c>gbxmlSpace</c>.
            </summary>
            <value>
            Property <c>gbxmlSurface_list</c> represents all surfaces enclosing this <c>gbxmlSpace</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSpace.gbxmlSpaceBoundary_list">
            <summary>
            Property <c>gbxmlSpaceBoundary_list</c> represents all space boundaries enclosing this <c>gbxmlSpace</c>.
            </summary>
            <value>
            Property <c>gbxmlSpaceBoundary_list</c> represents all space boundaries enclosing this <c>gbxmlSpace</c>.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlSpace.#ctor">
            <summary>
            This constructor initializes a new, empty <c>gbxmlSpace</c>.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlSpace.GetRoomBoundary(PlanGraphLibPy.Geometry.Point@)">
            <summary>
            This method returns the boundary of the space as a <c>Curve</c> at floor level.
            </summary>
            <param name="center">The center of the room at floor level.</param>
            <returns>
            Returns the boundary of the space as a <c>Curve</c> at floor level.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlSurface">
            <summary>
            Class <c>gbxmlSurface</c> contains the <c>id</c>, <c>surfaceType</c> and <c>PlanarGeometry</c> of the imported 
            surface object and will be converted to an <c>Edge_Space</c> in the <c>Graph_Plan</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSurface.surfaceType">
            <summary>
            Property <c>surfaceType</c> is directly imported from the gbXML file.
            </summary>
            <value>
            Property <c>surfaceType</c> is directly imported from the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSurface.id">
            <summary>
            Property <c>id</c> is directly imported from the gbXML file.
            </summary>
            <value>
            Property <c>id</c> is directly imported from the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSurface.PlanarGeometry">
            <summary>
            Property <c>PlanarGeometry</c> is directly imported from the gbXML file and represents the geometry of the 
            surface.
            </summary>
            <value>
            Property <c>PlanarGeometry</c> is directly imported from the gbXML file and represents the geometry of the 
            surface.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSurface.Opening_list">
            <summary>
            Property <c>Opening_list</c> represents all openings present in this <c>gbxmlSurface</c>.
            </summary>
            <value>
            Property <c>Opening_list</c> represents all openings present in this <c>gbxmlSurface</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSurface.gbxmlSpace_list">
            <summary>
            Property <c>gbxmlSpace_list</c> represents all spaces that use this <c>gbxmlSurface</c> as space boundary.
            </summary>
            <value>
            Property <c>gbxmlSpace_list</c> represents all spaces that use this <c>gbxmlSurface</c> as space boundary.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlSurface.#ctor">
            <summary>
            This constructor initializes a new, empty <c>gbxmlSurface</c>.
            </summary>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlOpening">
            <summary>
            Class <c>gbxmlOpening</c> contains the <c>id</c>, <c>openingType</c> and <c>PlanarGeometry</c> of the imported opening object.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlOpening.openingType">
            <summary>
            Property <c>openingType</c> is directly imported from the gbXML file.
            </summary>
            <value>
            Property <c>openingType</c> is directly imported from the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlOpening.id">
            <summary>
            Property <c>id</c> is directly imported from the gbXML file.
            </summary>
            <value>
            Property <c>id</c> is directly imported from the gbXML file.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlOpening.PlanarGeometry">
            <summary>
            Property <c>PlanarGeometry</c> is directly imported from the gbXML file and represents the geometry of the 
            opening.
            </summary>
            <value>
            Property <c>PlanarGeometry</c> is directly imported from the gbXML file and represents the geometry of the 
            opening.
            </value>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlSpaceBoundary">
            <summary>
            Class <c>gbxmlSpaceBoundary</c> contains the <c>surfaceIdRef</c> and <c>PlanarGeometry</c> of the imported boundary object.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSpaceBoundary.surfaceIdRef">
            <summary>
            Property <c>surfaceIdRef</c> is directly imported from the gbXML file and represents the id of the surface 
            that defines this space boundary.
            </summary>
            <value>
            Property <c>surfaceIdRef</c> is directly imported from the gbXML file and represents the id of the surface 
            that defines this space boundary.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlSpaceBoundary.PlanarGeometry">
            <summary>
            Property <c>PlanarGeometry</c> is directly imported from the gbXML file and represents the geometry of the 
            space boundary.
            </summary>
            <value>
            Property <c>PlanarGeometry</c> is directly imported from the gbXML file and represents the geometry of the 
            space boundary.
            </value>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlPolyline">
            <summary>
            Class <c>gbxmlPolyline</c> makes it possible to save a <c>PlanarGeometry</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlPolyline.Points">
            <summary>
            Property <c>Points</c> represents the ordered list of points defining this <c>gbxmlPolyline</c>.
            </summary>
            <value>
            Property <c>Points</c> represents the ordered list of points defining this <c>gbxmlPolyline</c>.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlPolyline.#ctor">
            <summary>
            This constructor initializes a new, empty <c>gbxmlPolyline</c>.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlPolyline.ToRhinoPolyline">
            <summary>
            This method converts this <c>gbxmlPolyline</c> to a <c>Rhino.Geometry.Polyline</c>.
            </summary>
            <returns>
            Returns a <c>Rhino.Geometry.Polyline</c> equivalent to this <c>gbxmlPolyline</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.gbxmlPolyline.ToPolyline">
            <summary>
            This method converts this <c>gbxmlPolyline</c> to a <c>Polyline</c>.
            </summary>
            <returns>
            Returns a <c>Polyline</c> equivalent to this <c>gbxmlPolyline</c>.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.gbxmlPoint3d">
            <summary>
            Class <c>gbxmlPoint3d</c> makes it possible to save a <c>PlanarGeometry</c> in a <c>gbxmlPolyline</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlPoint3d.x">
            <summary>
            Property <c>x</c> represents the x coordinate of this <c>gbxmlPoint3d</c> as double.
            </summary>
            <value>
            Property <c>x</c> represents the x coordinate of this <c>gbxmlPoint3d</c> as double.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlPoint3d.y">
            <summary>
            Property <c>y</c> represents the y coordinate of this <c>gbxmlPoint3d</c> as double.
            </summary>
            <value>
            Property <c>y</c> represents the y coordinate of this <c>gbxmlPoint3d</c> as double.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.gbxmlPoint3d.z">
            <summary>
            Property <c>z</c> represents the z coordinate of this <c>gbxmlPoint3d</c> as double.
            </summary>
            <value>
            Property <c>z</c> represents the z coordinate of this <c>gbxmlPoint3d</c> as double.
            </value>
        </member>
        <member name="T:PlanGraphLibPy.Import_to_graph.PNGtoGH">
            <summary>
            Class <c>PNGtoGH</c> makes it possible to convert an image of a floor plan formatted in the same way 
            as the RPlan dataset to a <c>Graph_Plan</c>.
            More information about the RPlan dataset can be found through the following 
            link: http://staff.ustc.edu.cn/~fuxm/projects/DeepLayout/index.html
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.PNGtoGH.RoomLabels">
            <summary>
            Property <c>RoomLabels</c> represents an ordered list of the labels of the rooms/nodes.
            </summary>
            <value>
            Property <c>RoomLabels</c> represents an ordered list of the labels of the rooms/nodes.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.PNGtoGH.RoomCurves">
            <summary>
            Property <c>RoomCurves</c> represents an ordered list of the boundaries of the rooms/nodes.
            </summary>
            <value>
            Property <c>RoomCurves</c> represents an ordered list of the boundaries of the rooms/nodes.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.PNGtoGH.IntDoorCurves">
            <summary>
            Property <c>IntDoorCurves</c> represents a list of the interior doors as curves.
            </summary>
            <value>
            Property <c>IntDoorCurves</c> represents a list of the interior doors as curves.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.PNGtoGH.ExtDoorCurves">
            <summary>
            Property <c>ExtDoorCurves</c> represents a list of the exterior doors as curves.
            </summary>
            <value>
            Property <c>ExtDoorCurves</c> represents a list of the exterior doors as curves.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Import_to_graph.PNGtoGH.ExtWallCurves">
            <summary>
            Property <c>ExtWallCurves</c> represents a list of the exterior walls as curves.
            </summary>
            <value>
            Property <c>ExtWallCurves</c> represents a list of the exterior walls as curves.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.PNGtoGH.#ctor(System.String)">
            <summary>
            This constructor initializes a new <c>PNGtoGH</c>.
            </summary>
            <example>For example:
            <code>
            // The example uses datapoint "0.png" of the RPlan dataset.
            // This code is made inside a Grasshopper C# Script component and thus gives output inside Grasshopper/Rhino.
            
            string path_to_png = "C:\\path\\to\\image\\0.png";
            
            PNGtoGH converter = new PNGtoGH(path_to_png);
            Graph_Plan g = converter.GetPlanGraph(true, 0.01, new Dictionary&lt;string, double&gt;(), true);
            
            // Find the path between the master room and the ouside world (outside the house)
            List&lt;List&lt;Node&gt;&gt; allPaths = g.AllPaths(g.GetNodes()[4], g.GetNodes()[6], new List&lt;string&gt;() { "door", "exterior door" });
            int pathNr = 1;
            string txt = "";
            foreach (List&lt;Node&gt; path in allPaths)
            {
            	txt += "Path " + pathNr + " exists of the following space sequence:\n";
            	foreach (Node node in path)
            	{
            		txt += "    " + node.NodeLabel + "\n";
            	}
            	pathNr++;
            }
            
            A = txt;
            B = converter.ExtDoorCurves;
            C = converter.ExtWallCurves;
            D = converter.IntDoorCurves;
            E = converter.RoomCurves;
            
            // The example displays the following output for A in a panel:
            //    Path 1 exists of the following space sequence:
            //        master room
            //        living room
            //        outside world
            // The example outputs curves that display the walls, doors and rooms for B, C, D and E in the Rhino viewport.
            </code>
            </example>
            <param name="path">The path to the png file.</param>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.PNGtoGH.#ctor(System.Collections.Generic.List{System.String},System.Collections.Generic.List{Rhino.Geometry.Curve},System.Collections.Generic.List{Rhino.Geometry.Curve},System.Collections.Generic.List{Rhino.Geometry.Curve},System.Collections.Generic.List{Rhino.Geometry.Curve})">
            <summary>
            This constructor initializes a new <c>PNGtoGH</c>, but instead of gathering polylines from a png file, the 
            information is given as Rhino curves.
            </summary>
            <param name="roomLabels">An ordered list of the labels of the rooms/nodes.</param>
            <param name="roomPolylines">An ordered list of the boundaries of the rooms/nodes.</param>
            <param name="intDoorPolylines">A list of the interior doors as curves.</param>
            <param name="extDoorPolylines">A list of the exterior doors as curves.</param>
            <param name="extWallPolylines">A list of the exterior walls as curves.</param>
        </member>
        <member name="M:PlanGraphLibPy.Import_to_graph.PNGtoGH.GetPlanGraph(System.Boolean,System.Double,System.Collections.Generic.Dictionary{System.String,System.Double},System.Boolean)">
            <summary>
            This method returns the new <c>Graph_Plan</c>.
            </summary>
            <example>For example:
            <code>
            // The example uses datapoint "0.png" of the RPlan dataset.
            // This code is made inside a Grasshopper C# Script component and thus gives output inside Grasshopper/Rhino.
            
            string path_to_png = "C:\\path\\to\\image\\0.png";
            
            PNGtoGH converter = new PNGtoGH(path_to_png);
            Graph_Plan g = converter.GetPlanGraph(true, 0.01, new Dictionary&lt;string, double&gt;(), true);
            
            // Find the path between the master room and the ouside world (outside the house)
            List&lt;List&lt;Node&gt;&gt; allPaths = g.AllPaths(g.GetNodes()[4], g.GetNodes()[6], new List&lt;string&gt;() { "door", "exterior door" });
            int pathNr = 1;
            string txt = "";
            foreach (List&lt;Node&gt; path in allPaths)
            {
            	txt += "Path " + pathNr + " exists of the following space sequence:\n";
            	foreach (Node node in path)
            	{
            		txt += "    " + node.NodeLabel + "\n";
            	}
            	pathNr++;
            }
            
            A = txt;
            B = converter.ExtDoorCurves;
            C = converter.ExtWallCurves;
            D = converter.IntDoorCurves;
            E = converter.RoomCurves;
            
            // The example displays the following output for A in a panel:
            //    Path 1 exists of the following space sequence:
            //        master room
            //        living room
            //        outside world
            // The example outputs curves that display the walls, doors and rooms for B, C, D and E in the Rhino viewport.
            </code>
            </example>
            <param name="inclExt">Include the exterior as a node called "outside world" in the graph.</param>
            <param name="tolerance">The tolerance of the image.</param>
            <param name="wallThicknesses">If <c>autoThickness</c> is not set to true, <c>wallThicknesses</c> can be added 
            as a dictionary of edge labels (wall names) and their thicknesses.</param>
            <param name="autoThickness">True if all walls are equally thick and the thickness is derived automatically.</param>
            <returns>
            Returns a new <c>Graph_Plan</c> based on the png file.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Matching.BipartiteMatchingFunctions">
            <summary>
            Class <c>BipartiteMatchingFunctions</c> finds the node pairs with the lowest overall cost.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Matching.BipartiteMatchingFunctions.HungarianAlgorithm(System.Int32[0:,0:])">
            <summary>
            This method gets the node pairs with the lowest overall cost.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            double[,] costs_al = aligner.computeAligningCosts(g1, g2, new List&lt;double&gt;() { 0.65, 0.35 });
            double[,] costs_gr = aligner.computeGraphletAligningCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            double[,] costs_tr = aligner.computeTreeCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            double[,] costs = aligner.computeTotalAligningCosts(new List&lt;double[,]&gt;() { costs_al, costs_gr, costs_tr }, new List&lt;double&gt;() { 0.3, 0.3, 0.3 });
            
            Console.WriteLine("The total costs:");
            for (int i = 0; i &lt; costs.GetLength(0); i++)
            {
            	string txt = "    ";
            	for (int j = 0; j &lt; costs.GetLength(1); j++)
            	{
            		if (Convert.ToDouble(costs.GetValue(i, j)) &gt;= double.MaxValue)
            		{
            			string mytxt = "+inf" + " ";
            			txt += mytxt.PadRight(7, ' ');
            		}
            		else
            		{
            			string mytxt = Math.Round(Convert.ToDouble(costs.GetValue(i, j)), 2) + " ";
            			txt += mytxt.PadRight(7, ' ');
            		}
            	}
            	Console.WriteLine(txt);
            }
            
            int[,] costs_int = new int[costs.GetLength(0), costs.GetLength(1)];
            for (int u = 0; u &lt; costs.GetLength(0); u++)
            {
            	for (int v = 0; v &lt; costs.GetLength(1); v++)
            	{
            		if (costs[u, v] * 100 &gt;= int.MaxValue)
            		{
            			costs_int[u, v] = Int32.MaxValue;
            		}
            		else
            		{
            			costs_int[u, v] = Convert.ToInt32(costs[u, v] * 100);
            		}
            	}
            }
            
            List&lt;int[]&gt; pairs = BipartiteMatchingFunctions.HungarianAlgorithm(costs_int);
            foreach (int[] pair in pairs)
            {
            	Console.WriteLine(g1.GetNodes()[pair[0]].Name + " of graph 1 is matched to " + g2.GetNodes()[pair[1]].Name + " of graph 2");
            }
            
            // The example displays the following output:
            //    The total costs:
            //        0,05   0,57   0,77   +inf
            //        0,39   0,23   0,42   +inf
            //        0,59   0,42   0,23   +inf
            //        +inf   +inf   +inf   0,03
            // Front entrance of graph 1 is matched to Front entrance of graph 2
            // Left room of graph 1 is matched to Left room of graph 2
            // Right room of graph 1 is matched to Right room of graph 2
            // Sidewalk of graph 1 is matched to Sidewalk of graph 2
            </code>
            </example>
            <param name="matrix">The cost matrix between two graphs that can be calculated with the functions of 
            class <c>GraphAligner</c>.</param>
            <returns>
            Returns the node pairs with the lowest overall cost.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.BipartiteMatchingFunctions.AddIntegerListToHashSet(System.Collections.Generic.HashSet{System.Collections.Generic.List{System.Int32}},System.Collections.Generic.List{System.Int32})">
            <summary>
            This method adds a list of integers to a <c>HashSet</c> if and only if a list with the same integers in the same 
            order is not yet present in the set.
            </summary>
            <param name="set">The <c>HashSet</c> to which we want to add the list.</param>
            <param name="listToAdd">The list that we want to add.</param>
            <returns>
            Returns a set of unique lists of integers.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.BipartiteMatchingFunctions.GetIndexIntegerListInList(System.Collections.Generic.List{System.Collections.Generic.List{System.Int32}},System.Collections.Generic.List{System.Int32})">
            <summary>
            This method gets the index of the list in the set.
            </summary>
            <param name="set">The set of integer lists.</param>
            <param name="listToFind">The integer list we want to find.</param>
            <returns>
            Returns the index of the integer list in the set.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Matching.Graal">
            <summary>
            Class <c>Graal</c> is a graph aligner, which aligns two graphs with each other, i.e. matches their nodes to each other.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.Matching.Graal.BestAlignment">
            <summary>
            Property <c>BestAlignment</c> represents the list of node pairs, as index pairs, that are aligned.
            </summary>
            <value>
            Property <c>BestAlignment</c> represents the list of node pairs, as index pairs, that are aligned.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Matching.Graal.BestAlignmentAsNodes">
            <summary>
            Property <c>BestAlignmentAsNodes</c> represents the list of node pairs that are aligned.
            </summary>
            <value>
            Property <c>BestAlignmentAsNodes</c> represents the list of node pairs that are aligned.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Matching.Graal.FuncNodesNotAligned">
            <summary>
            Property <c>FuncNodesNotAligned</c> represents the list of nodes in the functional graph that are not aligned.
            </summary>
            <value>
            Property <c>FuncNodesNotAligned</c> represents the list of nodes in the functional graph that are not aligned.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Matching.Graal.GeomNodesNotAligned">
            <summary>
            Property <c>GeomNodesNotAligned</c> represents the list of nodes in the geometrical graph that are not aligned.
            </summary>
            <value>
            Property <c>GeomNodesNotAligned</c> represents the list of nodes in the geometrical graph that are not aligned.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Matching.Graal.TotalAligningCosts">
            <summary>
            Property <c>TotalAligningCosts</c> represents the total cost matrix that is used for the aligning process.
            </summary>
            <value>
            Property <c>TotalAligningCosts</c> represents the total cost matrix that is used for the aligning process.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Matching.Graal.FunctionalGraph">
            <summary>
            Property <c>FunctionalGraph</c> represents the functional graph.
            </summary>
            <value>
            Property <c>FunctionalGraph</c> represents the functional graph.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.Matching.Graal.GeometricalGraph">
            <summary>
            Property <c>GeometricalGraph</c> represents the geometrical graph.
            </summary>
            <value>
            Property <c>GeometricalGraph</c> represents the geometrical graph.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.Matching.Graal.#ctor(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Double[0:,0:],System.Collections.Generic.List{System.Int32[]},System.Collections.Generic.List{System.String})">
            <summary>
            This constructor initializes a new <c>Graal</c> and aligns the two graphs with each other.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Entrance", 3, new Point(1.5, 0.5, 0));
            n1.Name = "Front entrance";
            Node_Space n2 = new Node_Space("Room", 12, new Point(1.5, 3, 0));
            n2.Name = "Left room";
            Node_Space n3 = new Node_Space("Room", 25, new Point(5.5, 0.2, 0));
            n3.Name = "Right room";
            Node_Space n4 = new Node_Space(true);
            n4.Name = "Sidewalk";
            List&lt;Node_Space&gt; nodes1 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            List&lt;Node_Space&gt; nodes2 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge_Space e3 = new Edge_Space("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge_Space e4 = new Edge_Space("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge_Space&gt; edges1 = new List&lt;Edge_Space&gt;() { e1, e2, e3, e4 };
            List&lt;Edge_Space&gt; edges2 = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g1 = new Graph_Plan();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph_Plan g2 = new Graph_Plan();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner_Plan aligner = new GraphAligner_Plan();
            double[,] costs_al = aligner.computeAligningCosts(g1, g2, new List&lt;double&gt;() { 0.65, 0.35 });
            double[,] costs_gr = aligner.computeGraphletAligningCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            double[,] costs_tr = aligner.computeTreeCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            double[,] costs = aligner.computeTotalAligningCosts(new List&lt;double[,]&gt;() { costs_al, costs_gr, costs_tr }, new List&lt;double&gt;() { 0.3, 0.3, 0.3 });
            
            Graal graal = new Graal(g1, g2, costs, new List&lt;int[]&gt;() { }, new List&lt;string&gt;() { "door", "exterior door" });
            
            Console.WriteLine("The total costs:");
            for (int i = 0; i &lt; graal.TotalAligningCosts.GetLength(0); i++)
            {
            	string txt = "    ";
            	for (int j = 0; j &lt; graal.TotalAligningCosts.GetLength(1); j++)
            	{
            		if (Convert.ToDouble(graal.TotalAligningCosts.GetValue(i, j)) &gt;= double.MaxValue)
            		{
            			string mytxt = "+inf" + " ";
            			txt += mytxt.PadRight(7, ' ');
            		}
            		else
            		{
            			string mytxt = Math.Round(Convert.ToDouble(graal.TotalAligningCosts.GetValue(i, j)), 2) + " ";
            			txt += mytxt.PadRight(7, ' ');
            		}
            	}
            	Console.WriteLine(txt);
            }
            
            List&lt;int[]&gt; pairs = graal.BestAlignment;
            foreach (int[] pair in pairs)
            {
            	Console.WriteLine(g1.GetNodes()[pair[0]].Name + " of graph 1 is matched to " + g2.GetNodes()[pair[1]].Name + " of graph 2");
            }
            
            // The example displays the following output:
            //    The total costs:
            //        0,05   0,57   0,77   +inf
            //        0,39   0,23   0,42   +inf
            //        0,59   0,42   0,23   +inf
            //        +inf   +inf   +inf   0,03
            // Sidewalk of graph 1 is matched to Sidewalk of graph 2
            // Front entrance of graph 1 is matched to Front entrance of graph 2
            // Left room of graph 1 is matched to Left room of graph 2
            // Right room of graph 1 is matched to Right room of graph 2
            </code>
            </example>
            <param name="functionalGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geometricalGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="totalAligningCosts">The cost matrix between two graphs that can be calculated with the functions of 
            class <c>GraphAligner</c>.</param>
            <param name="fixedPairs">A list of node pairs that are already matched.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to align the nodes.</param>
        </member>
        <member name="M:PlanGraphLibPy.Matching.Graal.DijkstraShortestPath(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Node,System.Collections.Generic.List{System.String})">
            <summary>
            This method finds the Dijkstra shortest path between the source node and all other nodes in the graph. Only those edges 
            with an edge label present in <c>edgeLabelsToConsider</c> are taken into account.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Office");
            n1.Name= "Office of Louise";
            Node n2 = new Node("Office");
            n2.Name = "Office of Ruben";
            Node n3 = new Node("Corridor");
            n3.Name = "Back entrance";
            Node n4 = new Node("Corridor");
            n4.Name = "Front entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Reception area";
            Node n6 = new Node("Publicly accessible space");
            n6.Name = "Waiting room";
            Node n7 = new Node("Exterior");
            n7.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5, n6, n7 };
            
            // Make edges
            Edge e1 = new Edge("Door");
            e1.SetNodeStart(n1);
            e1.SetNodeEnd(n3);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n2);
            e2.SetNodeEnd(n3);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n6);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n6);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n5);
            e5.SetNodeEnd(n6);
            Edge e6 = new Edge("Door");
            e6.SetNodeStart(n4);
            e6.SetNodeEnd(n5);
            Edge e7 = new Edge("Exterior door");
            e7.SetNodeStart(n3);
            e7.SetNodeEnd(n7);
            Edge e8 = new Edge("Exterior door");
            e8.SetNodeStart(n4);
            e8.SetNodeEnd(n7);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5, e6, e7, e8 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            int[] dists = Graal.DijkstraShortestPath(g, n4, new List&lt;string&gt;() { "door", "exterior door" });
            
            Console.WriteLine("The starting point of our walk is the " + n4.Name + ":");
            for (int i = 0; i &lt; g.GetNodes().Count; i++)
            {
            	Console.WriteLine("    The distance to the " + g.GetNodes()[i].Name + " is " + dists[i]);
            }
            
            // The example displays the following output:
            //   The starting point of our walk is the Front entrance:
            //       The distance to the Office of Louise is 3
            //       The distance to the Office of Ruben is 3
            //       The distance to the Back entrance is 2
            //       The distance to the Front entrance is 0
            //       The distance to the Reception area is 1
            //       The distance to the Waiting room is 2
            //       The distance to the Sidewalk is 1
            </code>
            </example>
            <param name="graph">The graph in which we walk.</param>
            <param name="source">The source node where the walk starts.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when searching for the shortest path.</param>
            <returns>
            Returns the length of the shortest path for each node, starting from the source node.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Matching.GraalResult">
            <summary>
            Class <c>GraalResult</c> enables the calculation of the best alignment in class <c>Graal</c>.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraalResult.findBestAlignment(System.Collections.Generic.List{System.Collections.Generic.List{System.Int32[]}},System.Double[0:,0:])">
            <summary>
            This method finds the alignment with the lowest aligning cost.
            </summary>
            <param name="alignments">The list of possible alignments.</param>
            <param name="originalAligningCosts">The cost matrix.</param>
            <returns>
            Returns the alignment with the lowest matching cost.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraalResult.calculateMatchingCost(System.Collections.Generic.List{System.Int32[]},System.Double[0:,0:])">
            <summary>
            This method finds the matching cost of a given alignment.
            </summary>
            <param name="alignment">The alignment.</param>
            <param name="originalAligningCosts">The cost matrix.</param>
            <returns>
            Returns the matching cost.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraalResult.calculateMatchingCost(System.Collections.Generic.List{System.Int32[]},System.Int32[0:,0:])">
            <summary>
            This method finds the matching cost of a given alignment.
            </summary>
            <param name="alignment">The alignment.</param>
            <param name="originalAligningCosts">The cost matrix.</param>
            <returns>
            Returns the matching cost.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraalResult.findEdgeCorrectness(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Collections.Generic.List{System.Int32[]},System.Collections.Generic.List{System.String})">
            <summary>
            This method finds the edge correctness of an alignment. In other words, it finds the percentage of edges, present in the 
            functional graph, that can also be found when the functional graph is placed into the geometrical graph.
            A difference is made petween perfect matches (score of 1), wrong label matches (score of 0.5), too far matches 
            (score of 1/dist) and non existend matches where one of the nodes around the edge is not aligned (score of 0).
            </summary>
            <param name="funcGraph">The graph in which we walk.</param>
            <param name="geomGraph">The source node where the walk starts.</param>
            <param name="alignment">The alignment.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when searching for the edge correctness.</param>
            <returns>
            Returns the edge correctness (EC) of the alignment.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Matching.GraphAligner">
            <summary>
            Class <c>GraphAligner</c> collects functions that enable the calculation of cost matrices. 
            Such a cost matrix contains the costs of mapping two nodes with each other, i.e. difference between two nodes.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.normalizeAligningCosts(System.Double[0:,0:])">
            <summary>
            This method normalizes the values of the cost matrix between 0 and 1.
            </summary>
            <param name="aligningCosts">The first signature vector.</param>
            <returns>
            Returns the normalized cost matrix with values between 0 and 1.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeTotalAligningCosts(System.Collections.Generic.List{System.Double[0:,0:]},System.Collections.Generic.List{System.Double})">
            <summary>
            This method calculates the total cost matrix out of a set of cost matrices.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            double[,] costs_al = aligner.computeAligningCosts(g1, g2, new List&lt;double&gt;() { 0.65, 0.35 });
            double[,] costs_gr = aligner.computeGraphletAligningCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            double[,] costs_tr = aligner.computeTreeCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            double[,] costs = aligner.computeTotalAligningCosts(new List&lt;double[,]&gt;() { costs_al, costs_gr, costs_tr }, new List&lt;double&gt;() { 0.3, 0.3, 0.3 });
            
            Console.WriteLine("The aligning costs:");
            for (int i = 0; i &lt; costs_al.GetLength(0); i++)
            {
                string txt = "    ";
                for(int j = 0; j &lt; costs_al.GetLength(1); j++)
                {
                    string mytxt = Math.Round(costs_al[i, j], 2) + " ";
                    txt += mytxt.PadRight(7, ' '); // cost of matching node i from g1 to node j from g2
                }
                Console.WriteLine(txt);
            }
            
            Console.WriteLine("The graphlet vector costs:");
            for (int i = 0; i &lt; costs_gr.GetLength(0); i++)
            {
                string txt = "    ";
                for (int j = 0; j &lt; costs_gr.GetLength(1); j++)
                {
                    string mytxt = Math.Round(costs_gr[i, j], 2) + " ";
                    txt += mytxt.PadRight(7, ' '); // cost of matching node i from g1 to node j from g2
                }
                Console.WriteLine(txt);
            }
            
            Console.WriteLine("The tree edit distance costs:");
            for (int i = 0; i &lt; costs_tr.GetLength(0); i++)
            {
                string txt = "    ";
                for (int j = 0; j &lt; costs_tr.GetLength(1); j++)
                {
                    string mytxt = Math.Round(costs_tr[i, j], 2) + " ";
                    txt += mytxt.PadRight(7, ' '); // cost of matching node i from g1 to node j from g2
                }
                Console.WriteLine(txt);
            }
            
            Console.WriteLine("The total costs:");
            for (int i = 0; i &lt; costs.GetLength(0); i++)
            {
                string txt = "    ";
                for (int j = 0; j &lt; costs.GetLength(1); j++)
                {
                    string mytxt = Math.Round(costs[i, j], 2) + " ";
                    txt += mytxt.PadRight(7, ' '); // cost of matching node i from g1 to node j from g2
                }
                Console.WriteLine(txt);
            }
            // The example displays the following output:
            //    The aligning costs:
            //          0      0,7    0,7    0,83
            //          0,56   0,41   0,41   1
            //          0,56   0,41   0,41   1
            //          0,83   0,7    0,7    0
            //    The graphlet vector costs:
            //          0,14   0,3    0,3    0,3
            //          0,27   0,18   0,18   0,18
            //          0,27   0,18   0,18   0,18
            //          0,26   0,08   0,08   0,08
            //    The tree edit distance costs:
            //          0      1      1      1
            //          0,5    0,5    0,5    0,5
            //          0,5    0,5    0,5    0,5
            //          1      0      0      0
            //    The total costs:
            //          0,05   0,67   0,67   0,71
            //          0,44   0,37   0,37   0,56
            //          0,44   0,37   0,37   0,56
            //          0,7    0,26   0,26   0,03
            </code>
            </example>
            <param name="aligningCosts_list">The list of cost matrices.</param>
            <param name="fractions">The weight of importance of the matrices.</param>
            <returns>
            Returns the total cost of aligning two nodes, according to several cost matrices.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeLogDistance(System.Int32[],System.Int32[],System.Collections.Generic.List{System.Double})">
            <summary>
            This method compares two signature vectors and calculates the logarithmic distance between them.
            </summary>
            <param name="uSignature">The first signature vector.</param>
            <param name="vSignature">The second signature vector.</param>
            <param name="weights">The weights of importance of the properties in the signature.</param>
            <returns>
            Returns the logarithmic distance between the two signatures.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeNormDistance(System.Int32[],System.Int32[],System.Collections.Generic.List{System.Double})">
            <summary>
            This method compares two signature vectors and calculates the normal distance between them.
            </summary>
            <param name="uSignature">The first signature vector.</param>
            <param name="vSignature">The second signature vector.</param>
            <param name="weights">The weights of importance of the properties in the signature.</param>
            <returns>
            Returns the normal distance between the two signatures.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeAligningCosts(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Collections.Generic.List{System.Double},System.Boolean)">
            <summary>
            This method compares the signature vectors of the properties of every node pair.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            double[,] costs = aligner.computeAligningCosts(g1, g2, new List&lt;double&gt;() { 0.65, 0.35 });
            
            for(int i = 0; i &lt; costs.GetLength(0); i++)
            {
                string txt = "";
                for(int j = 0; j &lt; costs.GetLength(1); j++)
                {
                    string mytxt = Math.Round(costs[i, j], 2) + " ";
                    txt += mytxt.PadRight(7, ' '); // cost of matching node i from g1 to node j from g2
                }
                Console.WriteLine(txt);
            }
            // The example displays the following output:
            //    0      1      1      1,18
            //    0,81   0,59   0,59   1,43
            //    0,81   0,59   0,59   1,43
            //    1,18   1      1      0
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="weights">The weights of importance of the properties in the signature.</param>
            <param name="normDist">True if the distance needs to be calculated as a normal distance; false for logarithmic distance.</param>
            <returns>
            Returns the distance between the two signatures of every node pair. The lower the cost, the more similar 
            the properties of the nodes.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeAligningCost(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Collections.Generic.List{System.Double},System.Boolean)">
            <summary>
            This method compares the signature vectors of the properties of two nodes.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            SignatureProvider signatureProvider = new SignatureProvider();
            List&lt;int[]&gt; funcSignatures = signatureProvider.getSignatures(g1);
            List&lt;int[]&gt; geomSignatures = signatureProvider.getSignatures(g2);
            double cost1 = aligner.computeAligningCost(g1, g2, 1, 1, funcSignatures[1], geomSignatures[1], new List&lt;double&gt;() { 0.65, 0.35 }); // Left room
            double cost2 = aligner.computeAligningCost(g1, g2, 3, 3, funcSignatures[3], geomSignatures[3], new List&lt;double&gt;() { 0.65, 0.35 }); // Sidewalk
            
            Console.WriteLine("The cost of matching the signature of the left room in both graphs is " + cost1);
            Console.WriteLine("    As a distance between the vector of [degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignatures[1][0] + ", " + funcSignatures[1][1] + "]");
            Console.WriteLine("    [" + geomSignatures[1][0] + ", " + geomSignatures[1][1] + "]");
            Console.WriteLine("The cost of matching the signature of the sidewalk in both graphs is " + cost2);
            Console.WriteLine("    As a distance between the vector of [degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignatures[3][0] + ", " + funcSignatures[3][1] + "]");
            Console.WriteLine("    [" + geomSignatures[3][0] + ", " + geomSignatures[3][1] + "]");
            // The example displays the following output:
            //    The cost of matching the signature of the left room in both graphs is 0,5916079783099616
            //        As a distance between the vector of[degree "exterior door", degree "door"]:
            //        [0, 2]
            //        [0, 1]
            //    The cost of matching the signature of the sidewalk in both graphs is 0
            //        As a distance between the vector of[degree "exterior door", degree "door"]:
            //        [1, 0]
            //        [1, 0]
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="funcNodeId">A node from the functional <c>Graph</c> as the index of the node list.</param>
            <param name="geomNodeId">A node from the geometrical <c>Graph</c> as the index of the node list.</param>
            <param name="funcSignature">The signature vector of the functional node.</param>
            <param name="geomSignature">The signature vector of the geometrical node.</param>
            <param name="weights">The weights of importance of the properties in the signature.</param>
            <param name="normDist">True if the distance needs to be calculated as a normal distance; false for logarithmic distance.</param>
            <returns>
            Returns the distance between the two signatures of the two nodes. The lower the cost, the more similar 
            the properties of the nodes.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeGraphletAligningCosts(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Collections.Generic.List{System.String})">
            <summary>
            This method compares the graphlet degree vectors of every node pair.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            double[,] costs = aligner.computeGraphletAligningCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            
            for(int i = 0; i &lt; costs.GetLength(0); i++)
            {
                string txt = "";
                for(int j = 0; j &lt; costs.GetLength(1); j++)
                {
                    string mytxt = Math.Round(costs[i, j], 2) + " ";
                    txt += mytxt.PadRight(7, ' '); // cost of matching node i from g1 to node j from g2
                }
                Console.WriteLine(txt);
            }
            // The example displays the following output:
            //    0,14   0,3    0,3    0,3
            //    0,27   0,18   0,18   0,18
            //    0,27   0,18   0,18   0,18
            //    0,26   0,08   0,08   0,08
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to construct graphlet degree vectors.</param>
            <returns>
            Returns the distance between the two graphlet degree vectors of every node pair. The lower the cost, the more similar 
            the structure of the environments around the nodes.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeGraphletAligningCost(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Int32,System.Int32,System.Int64[],System.Int64[])">
            <summary>
            This method compares the graphlet degree vectors of two nodes.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            FourNodeGraphletOrbitCounter orcaFuncAll = new FourNodeGraphletOrbitCounter(new OrcaGraph(g1, g1.EdgeLabelsCollection));
            long[][] funcGDVall = orcaFuncAll.count(); // GDV = graphlet degree vector
            FourNodeGraphletOrbitCounter orcaGeomAll = new FourNodeGraphletOrbitCounter(new OrcaGraph(g2, g2.EdgeLabelsCollection));
            long[][] geomGDVall = orcaGeomAll.count();
            double cost1 = aligner.computeGraphletAligningCost(g1, g2, 1, 1, funcGDVall[1], geomGDVall[1]); // Left room
            double cost2 = aligner.computeGraphletAligningCost(g1, g2, 3, 3, funcGDVall[3], geomGDVall[3]); // Sidewalk
            
            Console.WriteLine("The cost of matching the GDV of the left room in both graphs is " + cost1);
            Console.WriteLine("The cost of matching the GDV of the sidewalk in both graphs is " + cost2);
            // The example displays the following output:
            //    The cost of matching the GDV of the left room in both graphs is 0,18204314024906607
            //    The cost of matching the GDV of the sidewalk in both graphs is 0,08212067997200553
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="funcNodeId">A node from the functional <c>Graph</c> as the index of the node list.</param>
            <param name="geomNodeId">A node from the geometrical <c>Graph</c> as the index of the node list.</param>
            <param name="funcGDV">The graphlet degree vector of the functional node.</param>
            <param name="geomGDV">The graphlet degree vector of the geometrical node.</param>
            <returns>
            Returns the distance between the two graphlet degree vectors of the two nodes. The lower the cost, the more similar 
            the structure of the environments around the nodes.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeTreeCosts(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Collections.Generic.List{System.String})">
            <summary>
            This method compares the <c>Tree</c> of every node pair. The cost is calculated as the edit distance between the two trees of two nodes.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            double[,] costs = aligner.computeTreeCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            
            for(int i = 0; i &lt; costs.GetLength(0); i++)
            {
            	string txt = "";
            	for(int j = 0; j &lt; costs.GetLength(1); j++)
            	{
            		txt += costs.GetValue(i, j) + " "; // cost of matching node i from g1 to node j from g2
            	}
            	Console.WriteLine(txt);
            }
            // The example displays the following output:
            //    0 4 4 4
            //    2 2 2 2
            //    2 2 2 2
            //    4 0 0 0
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to construct the trees.</param>
            <returns>
            Returns the edit distance between every node pair of the two graphs. The lower the cost, the more similar the trees 
            and thus the structure of the environments around the nodes are.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner.computeTreeCost(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Graph,System.Int32,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            This method compares the <c>Tree</c> of two nodes. The cost is calculated as the edit distance between the two trees.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            double cost1 = aligner.computeTreeCost(g1, g2, 1, 1, new List&lt;string&gt;() { "door" }); // Left room
            double cost2 = aligner.computeTreeCost(g1, g2, 3, 3, new List&lt;string&gt;() { "door", "exterior door" }); // Sidewalk
            
            Console.WriteLine("The cost of matching the tree structure of the left room in both graphs is " + cost1);
            Console.WriteLine("The cost of matching the tree structure of the sidewalk in both graphs is " + cost2);
            // The example displays the following output:
            //    The cost of matching the tree structure of the left room in both graphs is 2
            //    The cost of matching the tree structure of the sidewalk in both graphs is 0
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="funcNodeId">A node from the functional <c>Graph</c> as the index of the node list.</param>
            <param name="geomNodeId">A node from the geometrical <c>Graph</c> as the index of the node list.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to construct the trees.</param>
            <returns>
            Returns the edit distance between the two trees. The lower the cost, the more similar the trees and thus the 
            structure of the environments around the nodes are.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Matching.SignatureProvider">
            <summary>
            Class <c>SignatureProvider</c> collects functions that enable the calculation of signatures of nodes in a graph.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Matching.SignatureProvider.getSignatures(PlanGraphLibPy.The_graph.Graph)">
            <summary>
            This method gets the signature vector of every node of the graph.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            SignatureProvider signatureProvider = new SignatureProvider();
            List&lt;int[]&gt; funcSignatures = signatureProvider.getSignatures(g1);
            List&lt;int[]&gt; geomSignatures = signatureProvider.getSignatures(g2);
            double cost1 = aligner.computeAligningCost(g1, g2, 1, 1, funcSignatures[1], geomSignatures[1], new List&lt;double&gt;() { 0.65, 0.35 }); // Left room
            double cost2 = aligner.computeAligningCost(g1, g2, 3, 3, funcSignatures[3], geomSignatures[3], new List&lt;double&gt;() { 0.65, 0.35 }); // Sidewalk
            
            Console.WriteLine("The cost of matching the signature of the left room in both graphs is " + cost1);
            Console.WriteLine("    As a distance between the vector of [degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignatures[1][0] + ", " + funcSignatures[1][1] + "]");
            Console.WriteLine("    [" + geomSignatures[1][0] + ", " + geomSignatures[1][1] + "]");
            Console.WriteLine("The cost of matching the signature of the sidewalk in both graphs is " + cost2);
            Console.WriteLine("    As a distance between the vector of [degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignatures[3][0] + ", " + funcSignatures[3][1] + "]");
            Console.WriteLine("    [" + geomSignatures[3][0] + ", " + geomSignatures[3][1] + "]");
            // The example displays the following output:
            //    The cost of matching the signature of the left room in both graphs is 0,5916079783099616
            //        As a distance between the vector of[degree "exterior door", degree "door"]:
            //        [0, 2]
            //        [0, 1]
            //    The cost of matching the signature of the sidewalk in both graphs is 0
            //        As a distance between the vector of[degree "exterior door", degree "door"]:
            //        [1, 0]
            //        [1, 0]
            </code>
            </example>
            <param name="graph">The <c>Graph</c> from which we want to get all node signatures.</param>
            <returns>
            Returns the signatures of all nodes of the <c>Graph</c>. The signature is an array of node degrees for each edge label.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.SignatureProvider.getSignature(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Node)">
            <summary>
            This method gets the signature vector of the specified node of the graph.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Publicly accessible space");
            n4.Name = "Sidewalk";
            List&lt;Node&gt; nodes1 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            List&lt;Node&gt; nodes2 = new List&lt;Node&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge&gt; edges1 = new List&lt;Edge&gt;() { e1, e2, e3, e4 };
            List&lt;Edge&gt; edges2 = new List&lt;Edge&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph g1 = new Graph();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph g2 = new Graph();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner aligner = new GraphAligner();
            SignatureProvider signatureProvider = new SignatureProvider();
            int[] funcSignature_leftroom = signatureProvider.getSignature(g1, g1.GetNodes()[1]);
            int[] geomSignature_leftroom = signatureProvider.getSignature(g2, g2.GetNodes()[1]);
            double cost1 = aligner.computeAligningCost(g1, g2, 1, 1, funcSignature_leftroom, geomSignature_leftroom, new List&lt;double&gt;() { 0.65, 0.35 }); // Left room
            int[] funcSignature_sidewalk = signatureProvider.getSignature(g1, g1.GetNodes()[3]);
            int[] geomSignature_sidewalk = signatureProvider.getSignature(g2, g2.GetNodes()[3]);
            double cost2 = aligner.computeAligningCost(g1, g2, 3, 3, funcSignature_sidewalk, geomSignature_sidewalk, new List&lt;double&gt;() { 0.65, 0.35 }); // Sidewalk
            
            Console.WriteLine("The cost of matching the signature of the left room in both graphs is " + cost1);
            Console.WriteLine("    As a distance between the vector of [degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignature_leftroom[0] + ", " + funcSignature_leftroom[1] + "]");
            Console.WriteLine("    [" + geomSignature_leftroom[0] + ", " + geomSignature_leftroom[1] + "]");
            Console.WriteLine("The cost of matching the signature of the sidewalk in both graphs is " + cost2);
            Console.WriteLine("    As a distance between the vector of [degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignature_sidewalk[0] + ", " + funcSignature_sidewalk[1] + "]");
            Console.WriteLine("    [" + geomSignature_sidewalk[0] + ", " + geomSignature_sidewalk[1] + "]");
            // The example displays the following output:
            //    The cost of matching the signature of the left room in both graphs is 0,5916079783099616
            //        As a distance between the vector of[degree "exterior door", degree "door"]:
            //        [0, 2]
            //        [0, 1]
            //    The cost of matching the signature of the sidewalk in both graphs is 0
            //        As a distance between the vector of[degree "exterior door", degree "door"]:
            //        [1, 0]
            //        [1, 0]
            </code>
            </example>
            <param name="graph">The <c>Graph</c> that contains the node.</param>
            <param name="node">The <c>Node</c> from which we want to get the signature.</param>
            <returns>
            Returns the signature of this node in the graph. The signature is an array of node degrees for each edge label.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Matching.GraphAligner_Plan">
            <summary>
            Class <c>GraphAligner_Plan</c> collects functions that enable the calculation of cost matrices, specifically
            for aligning two graphs of the type <c>Graph_Plan</c>. Such a cost matrix contains the costs of mapping two 
            nodes of type <c>Node_Space</c> with each other, i.e. difference between two nodes.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner_Plan.computeAligningCosts(PlanGraphLibPy.The_graph.Graph_Plan,PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.Double},System.Boolean)">
            <summary>
            This method compares the signature vectors of the properties of every node pair.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Entrance", 3, new Point(1.5, 0.5, 0));
            n1.Name = "Front entrance";
            Node_Space n2 = new Node_Space("Room", 12, new Point(1.5, 3, 0));
            n2.Name = "Left room";
            Node_Space n3 = new Node_Space("Room", 25, new Point(5.5, 0.2, 0));
            n3.Name = "Right room";
            Node_Space n4 = new Node_Space(true);
            n4.Name = "Sidewalk";
            List&lt;Node_Space&gt; nodes1 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            List&lt;Node_Space&gt; nodes2 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge_Space e3 = new Edge_Space("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge_Space e4 = new Edge_Space("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge_Space&gt; edges1 = new List&lt;Edge_Space&gt;() { e1, e2, e3, e4 };
            List&lt;Edge_Space&gt; edges2 = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g1 = new Graph_Plan();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph_Plan g2 = new Graph_Plan();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner_Plan aligner = new GraphAligner_Plan();
            double[,] costs = aligner.computeAligningCosts(g1, g2, new List&lt;double&gt;() { 0.5, 0.25, 0.25 });
            
            for (int i = 0; i &lt; costs.GetLength(0); i++)
            {
                string txt = "";
                for(int j = 0; j &lt; costs.GetLength(1); j++)
                {
                    if (costs[i, j] &gt;= double.MaxValue)
                    {
                        string mytxt = "+inf" + " ";
                        txt += mytxt.PadRight(7, ' ');
                    }
                    else
                    {
                        string mytxt = Math.Round(costs[i, j], 2) + " ";
                        txt += mytxt.PadRight(7, ' '); // cost of matching node i from g1 to node j from g2
                    }
                }
                Console.WriteLine(txt);
            }
            // The example displays the following output:
            //    0      6,4    15,57  +inf
            //    6,38   0,5    9,21   +inf
            //    15,56  9,21   0,5    +inf
            //    +inf   +inf   +inf   0
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph_Plan</c> that will be mapped into the geometrical <c>Graph_Plan</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph_Plan</c> that is compared to the functional <c>Graph_Plan</c>.</param>
            <param name="weights">The weights of importance of the properties in the signature.</param>
            <param name="normDist">True if the distance needs to be calculated as a normal distance; false for logarithmic distance.</param>
            <returns>
            Returns the distance between the two signatures of every node pair. The lower the cost, the more similar 
            the properties of the nodes.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner_Plan.computeAligningCost(PlanGraphLibPy.The_graph.Graph_Plan,PlanGraphLibPy.The_graph.Graph_Plan,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Collections.Generic.List{System.Double},System.Boolean)">
            <summary>
            This method compares the signature vectors of the properties of two nodes of the type <c>Node_Space</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Entrance", 3, new Point(1.5, 0.5, 0));
            n1.Name = "Front entrance";
            Node_Space n2 = new Node_Space("Room", 12, new Point(1.5, 3, 0));
            n2.Name = "Left room";
            Node_Space n3 = new Node_Space("Room", 25, new Point(5.5, 0.2, 0));
            n3.Name = "Right room";
            Node_Space n4 = new Node_Space(true);
            n4.Name = "Sidewalk";
            List&lt;Node_Space&gt; nodes1 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            List&lt;Node_Space&gt; nodes2 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge_Space e3 = new Edge_Space("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge_Space e4 = new Edge_Space("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge_Space&gt; edges1 = new List&lt;Edge_Space&gt;() { e1, e2, e3, e4 };
            List&lt;Edge_Space&gt; edges2 = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g1 = new Graph_Plan();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph_Plan g2 = new Graph_Plan();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner_Plan aligner = new GraphAligner_Plan();
            SignatureProvider_Plan signatureProvider = new SignatureProvider_Plan();
            int[] funcSignature_leftroom = signatureProvider.getSignature(g1, g1.GetNodes()[1]);
            int[] geomSignature_leftroom = signatureProvider.getSignature(g2, g2.GetNodes()[1]);
            double cost1 = aligner.computeAligningCost(g1, g2, 1, 1, funcSignature_leftroom, geomSignature_leftroom, new List&lt;double&gt;() { 0.5, 0.25, 0.25 }); // Left room
            int[] funcSignature_sidewalk = signatureProvider.getSignature(g1, g1.GetNodes()[3]);
            int[] geomSignature_sidewalk = signatureProvider.getSignature(g2, g2.GetNodes()[3]);
            double cost2 = aligner.computeAligningCost(g1, g2, 3, 3, funcSignature_sidewalk, geomSignature_sidewalk, new List&lt;double&gt;() { 0.5, 0.25, 0.25 }); // Sidewalk
            
            Console.WriteLine("The cost of matching the signature of the left room in both graphs is " + cost1);
            Console.WriteLine("    As a distance between the vector of [area, degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignature_leftroom[0] + ", " + funcSignature_leftroom[1] + ", " + funcSignature_leftroom[2] + "]");
            Console.WriteLine("    [" + geomSignature_leftroom[0] + ", " + geomSignature_leftroom[1] + ", " + geomSignature_leftroom[2] + "]");
            Console.WriteLine("The cost of matching the signature of the sidewalk in both graphs is " + cost2);
            Console.WriteLine("    As a distance between the vector of [area, degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignature_sidewalk[0] + ", " + funcSignature_sidewalk[1] + ", " + funcSignature_sidewalk[2] + "]");
            Console.WriteLine("    [" + geomSignature_sidewalk[0] + ", " + geomSignature_sidewalk[1] + ", " + geomSignature_sidewalk[2] + "]");
            // The cost of matching the signature of the left room in both graphs is 0,5
            //      As a distance between the vector of [area, degree "exterior door", degree "door"]:
            //          [12, 0, 2]
            //          [12, 0, 1]
            // The cost of matching the signature of the sidewalk in both graphs is 0
            //      As a distance between the vector of [area, degree "exterior door", degree "door"]:
            //          [0, 1, 0]
            //          [0, 1, 0]
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph_Plan</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph_Plan</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="funcNodeId">A <c>Node_Space</c> from the functional <c>Graph_Plan</c> as the index of the node list.</param>
            <param name="geomNodeId">A <c>Node_Space</c> from the geometrical <c>Graph_Plan</c> as the index of the node list.</param>
            <param name="funcSignature">The signature vector of the functional <c>Node_Space</c>.</param>
            <param name="geomSignature">The signature vector of the geometrical <c>Node_Space</c>.</param>
            <param name="weights">The weights of importance of the properties in the signature.</param>
            <param name="normDist">True if the distance needs to be calculated as a normal distance; false for logarithmic distance.</param>
            <returns>
            Returns the distance between the two signatures of the two nodes of the type <c>Node_Space</c>. The lower the cost, 
            the more similar the properties of the nodes.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner_Plan.computeTreeCosts(PlanGraphLibPy.The_graph.Graph_Plan,PlanGraphLibPy.The_graph.Graph_Plan,System.Collections.Generic.List{System.String})">
            <summary>
            This method compares the <c>Tree</c> of every node pair. The cost is calculated as the edit distance between the two trees of two nodes of type <c>Node_Space</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Entrance", 3, new Point(1.5, 0.5, 0));
            n1.Name = "Front entrance";
            Node_Space n2 = new Node_Space("Room", 12, new Point(1.5, 3, 0));
            n2.Name = "Left room";
            Node_Space n3 = new Node_Space("Room", 25, new Point(5.5, 0.2, 0));
            n3.Name = "Right room";
            Node_Space n4 = new Node_Space(true);
            n4.Name = "Sidewalk";
            List&lt;Node_Space&gt; nodes1 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            List&lt;Node_Space&gt; nodes2 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge_Space e3 = new Edge_Space("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge_Space e4 = new Edge_Space("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge_Space&gt; edges1 = new List&lt;Edge_Space&gt;() { e1, e2, e3, e4 };
            List&lt;Edge_Space&gt; edges2 = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g1 = new Graph_Plan();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph_Plan g2 = new Graph_Plan();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner_Plan aligner = new GraphAligner_Plan();
            double[,] costs = aligner.computeTreeCosts(g1, g2, new List&lt;string&gt;() { "door", "exterior door" });
            
            for (int i = 0; i &lt; costs.GetLength(0); i++)
            {
                string txt = "";
                for (int j = 0; j &lt; costs.GetLength(1); j++)
                {
                    if (Convert.ToDouble(costs.GetValue(i, j)) &gt;= double.MaxValue)
                    {
                        string mytxt = "+inf" + " ";
                        txt += mytxt.PadRight(7, ' ');
                    }
                    else
                    {
                        string mytxt = costs.GetValue(i, j) + " ";
                        txt += mytxt.PadRight(7, ' ');
                    }
                }
                Console.WriteLine(txt);
            }
            // The example displays the following output:
            //    0      4      4      +inf
            //    2      2      2      +inf
            //    2      2      2      +inf
            //    +inf   +inf   +inf   0
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph_Plan</c> that will be mapped into the geometrical <c>Graph_Plan</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph_Plan</c> that is compared to the functional <c>Graph_Plan</c>.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to construct the trees.</param>
            <returns>
            Returns the edit distance between every node pair of the two graphs of type <c>Graph_Plan</c>. The lower the cost, the 
            more similar the trees and thus the structure of the environments around the nodes are.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.GraphAligner_Plan.computeTreeCost(PlanGraphLibPy.The_graph.Graph_Plan,PlanGraphLibPy.The_graph.Graph_Plan,System.Int32,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            This method compares the <c>Tree</c> of two nodes. The cost is calculated as the edit distance between the two trees.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Entrance", 3, new Point(1.5, 0.5, 0));
            n1.Name = "Front entrance";
            Node_Space n2 = new Node_Space("Room", 12, new Point(1.5, 3, 0));
            n2.Name = "Left room";
            Node_Space n3 = new Node_Space("Room", 25, new Point(5.5, 0.2, 0));
            n3.Name = "Right room";
            Node_Space n4 = new Node_Space(true);
            n4.Name = "Sidewalk";
            List&lt;Node_Space&gt; nodes1 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            List&lt;Node_Space&gt; nodes2 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge_Space e3 = new Edge_Space("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge_Space e4 = new Edge_Space("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge_Space&gt; edges1 = new List&lt;Edge_Space&gt;() { e1, e2, e3, e4 };
            List&lt;Edge_Space&gt; edges2 = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g1 = new Graph_Plan();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph_Plan g2 = new Graph_Plan();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner_Plan aligner = new GraphAligner_Plan();
            double cost1 = aligner.computeTreeCost(g1, g2, 1, 1, new List&lt;string&gt;() { "door" }); // Left room
            double cost2 = aligner.computeTreeCost(g1, g2, 3, 3, new List&lt;string&gt;() { "door", "exterior door" }); // Sidewalk
            
            Console.WriteLine("The cost of matching the tree structure of the left room in both graphs is " + cost1);
            Console.WriteLine("The cost of matching the tree structure of the sidewalk in both graphs is " + cost2);
            // The example displays the following output:
            //    The cost of matching the tree structure of the left room in both graphs is 2
            //    The cost of matching the tree structure of the sidewalk in both graphs is 0
            </code>
            </example>
            <param name="funcGraph">The functional <c>Graph</c> that will be mapped into the geometrical <c>Graph</c>.</param>
            <param name="geomGraph">The geometrical <c>Graph</c> that is compared to the functional <c>Graph</c>.</param>
            <param name="funcNodeId">A node from the functional <c>Graph</c> as the index of the node list.</param>
            <param name="geomNodeId">A node from the geometrical <c>Graph</c> as the index of the node list.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to construct the trees.</param>
            <returns>
            Returns the edit distance between the two trees. The lower the cost, the more similar the trees and thus the 
            structure of the environments around the nodes are.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.Matching.SignatureProvider_Plan">
            <summary>
            Class <c>SignatureProvider_Plan</c> collects functions that enable the calculation of signatures of nodes in a graph, 
            specifically for graphs if the type <c>Graph_Plan</c> with nodes of the type <c>Node_Space</c>.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.Matching.SignatureProvider_Plan.getSignatures(PlanGraphLibPy.The_graph.Graph_Plan)">
            <summary>
            This method gets the signature vector of every node of the <c>Graph_Plan</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Entrance", 3, new Point(1.5, 0.5, 0));
            n1.Name = "Front entrance";
            Node_Space n2 = new Node_Space("Room", 12, new Point(1.5, 3, 0));
            n2.Name = "Left room";
            Node_Space n3 = new Node_Space("Room", 25, new Point(5.5, 0.2, 0));
            n3.Name = "Right room";
            Node_Space n4 = new Node_Space(true);
            n4.Name = "Sidewalk";
            List&lt;Node_Space&gt; nodes1 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            List&lt;Node_Space&gt; nodes2 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge_Space e3 = new Edge_Space("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge_Space e4 = new Edge_Space("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge_Space&gt; edges1 = new List&lt;Edge_Space&gt;() { e1, e2, e3, e4 };
            List&lt;Edge_Space&gt; edges2 = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g1 = new Graph_Plan();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph_Plan g2 = new Graph_Plan();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner_Plan aligner = new GraphAligner_Plan();
            SignatureProvider_Plan signatureProvider = new SignatureProvider_Plan();
            List&lt;int[]&gt; funcSignatures = signatureProvider.getSignatures(g1);
            List&lt;int[]&gt; geomSignatures = signatureProvider.getSignatures(g2);
            double cost1 = aligner.computeAligningCost(g1, g2, 1, 1, funcSignatures[1], geomSignatures[1], new List&lt;double&gt;() { 0.5, 0.25, 0.25 }); // Left room
            double cost2 = aligner.computeAligningCost(g1, g2, 3, 3, funcSignatures[3], geomSignatures[3], new List&lt;double&gt;() { 0.5, 0.25, 0.25 }); // Sidewalk
            
            Console.WriteLine("The cost of matching the signature of the left room in both graphs is " + cost1);
            Console.WriteLine("    As a distance between the vector of [area, degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignatures[1][0] + ", " + funcSignatures[1][1] + ", " + funcSignatures[1][2] + "]");
            Console.WriteLine("    [" + geomSignatures[1][0] + ", " + geomSignatures[1][1] + ", " + geomSignatures[1][2] + "]");
            Console.WriteLine("The cost of matching the signature of the sidewalk in both graphs is " + cost2);
            Console.WriteLine("    As a distance between the vector of [area, degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignatures[3][0] + ", " + funcSignatures[3][1] + ", " + funcSignatures[3][2] + "]");
            Console.WriteLine("    [" + geomSignatures[3][0] + ", " + geomSignatures[3][1] + ", " + geomSignatures[3][2] + "]");
            // The example displays the following output:
            //    The cost of matching the signature of the left room in both graphs is 0,5
            //        As a distance between the vector of [area, degree "exterior door", degree "door"]:
            //        [12, 0, 2]
            //        [12, 0, 1]
            //    The cost of matching the signature of the sidewalk in both graphs is 0
            //        As a distance between the vector of [area, degree "exterior door", degree "door"]:
            //        [0, 1, 0]
            //        [0, 1, 0]
            </code>
            </example>
            <param name="graph">The <c>Graph_Plan</c> from which we want to get all node signatures.</param>
            <returns>
            Returns the signatures of all nodes of the <c>Graph_Plan</c>. The signature is an array of the area of 
            the space and the node degrees for each edge label.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.Matching.SignatureProvider_Plan.getSignature(PlanGraphLibPy.The_graph.Graph_Plan,PlanGraphLibPy.The_graph.Node_Space,System.Int32)">
            <summary>
            This method gets the signature vector of the specified node of the <c>Graph_Plan</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Entrance", 3, new Point(1.5, 0.5, 0));
            n1.Name = "Front entrance";
            Node_Space n2 = new Node_Space("Room", 12, new Point(1.5, 3, 0));
            n2.Name = "Left room";
            Node_Space n3 = new Node_Space("Room", 25, new Point(5.5, 0.2, 0));
            n3.Name = "Right room";
            Node_Space n4 = new Node_Space(true);
            n4.Name = "Sidewalk";
            List&lt;Node_Space&gt; nodes1 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            List&lt;Node_Space&gt; nodes2 = new List&lt;Node_Space&gt;() { n1, n2, n3, n4 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Exterior door");
            e1.SetNodeStart(n4);
            e1.SetNodeEnd(n1);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge_Space e3 = new Edge_Space("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge_Space e4 = new Edge_Space("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n3);
            List&lt;Edge_Space&gt; edges1 = new List&lt;Edge_Space&gt;() { e1, e2, e3, e4 };
            List&lt;Edge_Space&gt; edges2 = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g1 = new Graph_Plan();
            g1.AddNodes(nodes1);
            g1.AddEdges(edges1);
            Graph_Plan g2 = new Graph_Plan();
            g2.AddNodes(nodes2);
            g2.AddEdges(edges2);
            
            GraphAligner_Plan aligner = new GraphAligner_Plan();
            SignatureProvider_Plan signatureProvider = new SignatureProvider_Plan();
            int[] funcSignature_leftroom = signatureProvider.getSignature(g1, g1.GetNodes()[1]);
            int[] geomSignature_leftroom = signatureProvider.getSignature(g2, g2.GetNodes()[1]);
            double cost1 = aligner.computeAligningCost(g1, g2, 1, 1, funcSignature_leftroom, geomSignature_leftroom, new List&lt;double&gt;() { 0.5, 0.25, 0.25 }); // Left room
            int[] funcSignature_sidewalk = signatureProvider.getSignature(g1, g1.GetNodes()[3]);
            int[] geomSignature_sidewalk = signatureProvider.getSignature(g2, g2.GetNodes()[3]);
            double cost2 = aligner.computeAligningCost(g1, g2, 3, 3, funcSignature_sidewalk, geomSignature_sidewalk, new List&lt;double&gt;() { 0.5, 0.25, 0.25 }); // Sidewalk
            
            Console.WriteLine("The cost of matching the signature of the left room in both graphs is " + cost1);
            Console.WriteLine("    As a distance between the vector of [area, degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignature_leftroom[0] + ", " + funcSignature_leftroom[1] + ", " + funcSignature_leftroom[2] + "]");
            Console.WriteLine("    [" + geomSignature_leftroom[0] + ", " + geomSignature_leftroom[1] + ", " + geomSignature_leftroom[2] + "]");
            Console.WriteLine("The cost of matching the signature of the sidewalk in both graphs is " + cost2);
            Console.WriteLine("    As a distance between the vector of [area, degree \"exterior door\", degree \"door\"]:");
            Console.WriteLine("    [" + funcSignature_sidewalk[0] + ", " + funcSignature_sidewalk[1] + ", " + funcSignature_sidewalk[2] + "]");
            Console.WriteLine("    [" + geomSignature_sidewalk[0] + ", " + geomSignature_sidewalk[1] + ", " + geomSignature_sidewalk[2] + "]");
            // // The example displays the following output:
            //    The cost of matching the signature of the left room in both graphs is 0,5
            //        As a distance between the vector of [area, degree "exterior door", degree "door"]:
            //        [12, 0, 2]
            //        [12, 0, 1]
            //    The cost of matching the signature of the sidewalk in both graphs is 0
            //        As a distance between the vector of [area, degree "exterior door", degree "door"]:
            //        [0, 1, 0]
            //        [0, 1, 0]
            </code>
            </example>
            <param name="graph">The <c>Graph_Plan</c> that contains the node.</param>
            <param name="node">The <c>Node_Space</c> from which we want to get the signature.</param>
            <returns>
            Returns the signature of this node in the <c>Grpah_Plan</c>. The signature is an array of the area of 
            the space and the node degrees for each edge label.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.The_graph.Edge">
            <summary>
            Class <c>Edge</c> constructs an edge with its label, start node and end node.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Edge.NodeStart">
            <summary>
            Property <c>NodeStart</c> represents the starting node of the <c>Edge</c>.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeStart().Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <value>
            Property <c>NodeStart</c> represents the starting node of the <c>Edge</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Edge.NodeEnd">
            <summary>
            Property <c>NodeEnd</c> represents the node where the <c>Edge</c> arrives.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeEnd().Name);
            // The example displays the following output:
            //    Entrance
            </code>
            </example>
            <value>
            Property <c>NodeEnd</c> represents the node where the <c>Edge</c> arrives.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Edge.EdgeLabel">
            <summary>
            Property <c>EdgeLabel</c> represents the edge label of the <c>Edge</c> as a string.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.EdgeLabel);
            // The example displays the following output:
            //    door
            </code>
            </example>
            <value>
            Property <c>EdgeLabel</c> represents the edge label of the <c>Edge</c> as a string.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Edge.GUID">
            <summary>
            Property <c>GUID</c> represents unique identifier of the <c>Edge</c>.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GUID);
            // The example displays the following output:
            //    e8bad64e-a831-4253-84f0-c05642759220
            </code>
            </example>
            <value>
            Property <c>GUID</c> represents unique identifier of the <c>Edge</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Edge.dynamicProperties">
            <summary>
            Property <c>dynamicProperties</c> is a dynamic dictionary to add all sorts of properties to this <c>Edge</c>.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            e.dynamicProperties["width"] = 0.9;
            
            Console.WriteLine(e.dynamicProperties["width"]);
            // The example displays the following output:
            //    0,9
            </code>
            </example>
            <value>
            Property <c>dynamicProperties</c> is a dynamic dictionary to add all sorts of properties to this <c>Edge</c>.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge.#ctor(System.String)">
            <summary>
            This constructor initializes a new <c>Edge</c>.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            </code>
            </example>
            <param name="edgelabel">The label of the <c>Edge</c> as a string.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge.#ctor">
            <summary>
            This constructor initializes a new <c>Edge</c>.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge();
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            </code>
            </example>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge.SetNodeStart(PlanGraphLibPy.The_graph.Node)">
            <summary>
            This method sets the node at the start of the <c>Edge</c>.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeStart().Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <param name="node">The starting node of the <c>Edge</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge.GetNodeStart">
            <summary>
            This method gets the node at the start of the <c>Edge</c>.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeStart().Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <returns>
            Returns the starting node of the <c>Edge</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge.SetNodeEnd(PlanGraphLibPy.The_graph.Node)">
            <summary>
            This method sets the node where the <c>Edge</c> arrives.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeEnd().Name);
            // The example displays the following output:
            //    Entrance
            </code>
            </example>
            <param name="node">The node where the <c>Edge</c> arrives.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge.GetNodeEnd">
            <summary>
            This method gets the node where the <c>Edge</c> arrives.
            </summary>
            <example>For example:
            <code>
            Node n1 = new Node("Office");
            n1.Name = "Office of Louise";
            Node n2 = new Node("Corridor");
            n2.Name = "Entrance";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2 };
            
            Edge e = new Edge("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeEnd().Name);
            // The example displays the following output:
            //    Entrance
            </code>
            </example>
            <returns>
            Returns the node where the <c>Edge</c> arrives.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.The_graph.Graph">
            <summary>
            Class <c>Graph</c> constructs an undirected graph with its nodes and edges.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph.Nodes">
            <summary>
            Property <c>Nodes</c> represents the list of nodes in this <c>Graph</c>.
            </summary>
            <value>
            Property <c>Nodes</c> represents the list of nodes in this <c>Graph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph.Edges">
            <summary>
            Property <c>Edges</c> represents the list of edges in this <c>Graph</c>.
            </summary>
            <value>
            Property <c>Edges</c> represents the list of edges in this <c>Graph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph.GUID">
            <summary>
            Property <c>GUID</c> represents the uniquely generated GUID of this <c>Graph</c>.
            </summary>
            <value>
            Property <c>GUID</c> represents the uniquely generated GUID of this <c>Graph</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph.dynamicProperties">
             <summary>
             Property <c>dynamicProperties</c> is a dynamic dictionary to add all sorts of properties to this <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             g.dynamicProperties["address"] = "Jozef Plateaustraat 22\n9000 Gent\nBelgium";
            
             Console.WriteLine(g.dynamicProperties["address"]);
             // The example displays the following output:
             //    Jozef Plateaustraat 22
             //    9000 Gent
             //    Belgium
             </code>
             </example>
             <value>
             Property <c>dynamicProperties</c> is a dynamic dictionary to add all sorts of properties to this <c>Graph</c>.
             </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph.NodeLabelsCollection">
             <summary>
             Property <c>NodeLabelsCollection</c> is a collection of all node labels in this <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(string label in g.NodeLabelsCollection)
             {
                 Console.WriteLine(label);
             }
             // The example displays the following output:
             //    office
             //    corridor
             </code>
             </example>
             <value>
             Property <c>NodeLabelsCollection</c> is a collection of all node labels in this <c>Graph</c>.
             </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph.EdgeLabelsCollection">
             <summary>
             Property <c>EdgeLabelsCollection</c> is a collection of all edge labels in this <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(string label in g.EdgeLabelsCollection)
             {
                 Console.WriteLine(label);
             }
             // The example displays the following output:
             //    door
             //    wall
             </code>
             </example>
             <value>
             Property <c>EdgeLabelsCollection</c> is a collection of all edge labels in this <c>Graph</c>.
             </value>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.#ctor">
             <summary>
             This constructor initializes a new empty <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             </code>
             </example>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.AddNodes(System.Collections.Generic.List{PlanGraphLibPy.The_graph.Node})">
             <summary>
             This method adds a list of nodes to the <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Node node in g.GetNodes())
             {
                 Console.WriteLine(node.NodeLabel + ": " + node.Name);
             }
             // The example displays the following output:
             //    office: Office of Louise
             //    office: Office of Ruben
             //    corridor:
             </code>
             </example>
             <param name="nodes">The list of nodes that need to be added to the <c>Graph</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetNodes">
             <summary>
             This method returns the <c>Nodes</c> of the <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Node node in g.GetNodes())
             {
                 Console.WriteLine(node.NodeLabel + ": " + node.Name);
             }
             // The example displays the following output:
             //    office: Office of Louise
             //    office: Office of Ruben
             //    corridor:
             </code>
             </example>
             <returns>
             Returns all <c>Nodes</c> of the <c>Graph</c>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.AddEdges(System.Collections.Generic.List{PlanGraphLibPy.The_graph.Edge})">
             <summary>
             This method adds a list of edges to the <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Edge edge in g.GetEdges())
             {
                 Console.WriteLine(edge.EdgeLabel);
             }
             // The example displays the following output:
             //    door
             //    door
             //    wall
             </code>
             </example>
             <param name="edges">The list of edges that need to be added to the <c>Graph</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetEdges">
             <summary>
             This method returns the <c>Edges</c> of the <c>Graph</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Edge edge in g.GetEdges())
             {
                 Console.WriteLine(edge.EdgeLabel);
             }
             // The example displays the following output:
             //    door
             //    door
             //    wall
             </code>
             </example>
             <returns>
             Returns all <c>Edges</c> of the <c>Graph</c>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetNeighbours(PlanGraphLibPy.The_graph.Node,System.String)">
             <summary>
             This method gets all neighbouring nodes of a predefined <c>node</c>. Only those edges with 
             the specified <c>edgelabel</c> are taken into account when searching for neighbours, all other 
             edges are ignored.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             List&lt;Node&gt; neighbours = g.GetNeighbours(n1, "door");
            
             foreach(Node neighbour in neighbours)
             {
                 Console.WriteLine(neighbour.NodeLabel + ": " + neighbour.Name);
             }
             // The example displays the following output:
             //    corridor:
             </code>
             </example>
             <param name="node">The node from which we want to know its neightbours.</param>
             <param name="edgeLabel">Only edges with this label are taken into account.</param>
             <returns>
             Returns all neighbours of the <c>node</c> as a list of nodes.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetNeighbours(PlanGraphLibPy.The_graph.Node,System.Collections.Generic.List{System.String})">
             <summary>
             This method gets all neighbouring nodes of a predefined <c>node</c>. Only those edges with 
             an edge label present in <c>edgeLabels</c> are taken into account when searching for neighbours, 
             all other edges are ignored.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             List&lt;Node&gt; neighbours = g.GetNeighbours(n1, g.EdgeLabelsCollection);
            
             foreach(Node neighbour in neighbours)
             {
                 Console.WriteLine(neighbour.NodeLabel + ": " + neighbour.Name);
             }
             // The example displays the following output:
             //    office: Office of Ruben
             //    corridor:
             </code>
             </example>
             <param name="node">The node from which we want to know its neightbours.</param>
             <param name="edgeLabels">Only edges with these labels are taken into account.</param>
             <returns>
             Returns all neighbours of the <c>node</c> as a list of nodes.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetAdjMatrix(System.Collections.Generic.List{System.String})">
             <summary>
             This method generates the adjacency matrix of the <c>Graph</c>. Only those edges present 
             in <c>edgeLabelsToConsider</c> are taken into account when constructing the 2D matrix.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             int[,] adj_matrix = g.GetAdjMatrix(new List&lt;string&gt;() { "door" });
            
             if (Convert.ToInt32(adj_matrix.GetValue(0, 1)) == 1)
             {
                 Console.WriteLine(g.GetNodes()[0].Name + " and " + g.GetNodes()[1].Name + " are connected with a door.");
             }
             else if (Convert.ToInt32(adj_matrix.GetValue(0, 1)) == 0)
             {
                 Console.WriteLine(g.GetNodes()[0].Name + " and " + g.GetNodes()[1].Name + " are not connected with a door.");
             }
             // The example displays the following output:
             //   Office of Louise and Office of Ruben are not connected with a door.
             </code>
             </example>
             <param name="edgeLabelsToConsider">The edge labels that are taken into account when constructing the adjacency matrix.</param>
             <returns>
             Returns the adjacency matrix of the <c>Graph</c> as a 2D matrix with 0 if there is no edge between the nodes and 1 
             if there is a connecting edge. The columns and rows of the matrix are in the same order as the list of nodes that can 
             be recieved by using <c>GetNodes()</c>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetNodeDegrees(System.String)">
             <summary>
             This method returns the degrees of the <c>Nodes</c> in the <c>Graph</c>. Only those edges with the predefined 
             <c>edgelabel</c> are taken into account.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             int[] degrees = g.GetNodeDegrees("door");
            
             for (int i = 0; i &lt; degrees.Length; i++)
             {
                 Console.WriteLine("The degree of the " + g.GetNodes()[i].Name + " is " + degrees[i] + ".");
             }
             // The example displays the following output:
             //   The degree of the Office of Louise is 1.
             //   The degree of the Office of Ruben is 1.
             //   The degree of the Corridor is 2.
             </code>
             </example>
             <param name="edgelabel">The edge label that is taken into account when counting the node degrees.</param>
             <returns>
             Returns the degrees as integers in the same order as the list of nodes that can be recieved by using <c>GetNodes()</c>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetNodeDegrees(System.Collections.Generic.List{System.String})">
             <summary>
             This method returns the degrees of the <c>Nodes</c> in the <c>Graph</c>. Only those edges with an edge label 
             present in <c>edgelabels</c> are taken into account.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             int[] degrees = g.GetNodeDegrees(new List&lt;string&gt;() { "door" });
            
             for (int i = 0; i &lt; degrees.Length; i++)
             {
                 Console.WriteLine("The degree of the " + g.GetNodes()[i].Name + " is " + degrees[i] + ".");
             }
             // The example displays the following output:
             //   The degree of the Office of Louise is 1.
             //   The degree of the Office of Ruben is 1.
             //   The degree of the Corridor is 2.
             </code>
             </example>
             <param name="edgelabels">The edge labels that are taken into account when counting the node degrees.</param>
             <returns>
             Returns the degrees as integers in the same order as the list of nodes that can be recieved by using <c>GetNodes()</c>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetNodeDegree(PlanGraphLibPy.The_graph.Node,System.Collections.Generic.List{System.String})">
             <summary>
             This method returns the degree of the predefined <c>node</c>. Only those edges with an edge label 
             present in <c>edgelabels</c> are taken into account.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             int degree = g.GetNodeDegree(n1, new List&lt;string&gt;() { "door" });
            
             Console.WriteLine("The degree of the " + n1.Name + " is " + degree + ".");
             // The example displays the following output:
             //   The degree of the Office of Louise is 1.
             </code>
             </example>
             <param name="node">The node from which the degree is returned.</param>
             <param name="edgelabels">The edge labels that are taken into account when counting the node degree.</param>
             <returns>
             Returns the degree of the <c>node</c> as integer.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetDegreeHistogram(System.Collections.Generic.List{System.String})">
             <summary>
             This method returns a dictionary that represents the degree histogram of the <c>Graph</c> with the degrees 
             as keys and the number of times a degree occurs as values.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             Dictionary&lt;int, int&gt; degree_histogram = g.GetDegreeHistogram(new List&lt;string&gt;() { "door" });
            
             foreach (KeyValuePair&lt;int, int&gt; pair in degree_histogram)
             {
                 Console.WriteLine("There are " + pair.Value + " nodes with degree " + pair.Key + ".");
             }
             // The example displays the following output:
             //   There are 0 nodes with degree 0.
             //   There are 2 nodes with degree 1.
             //   There are 1 nodes with degree 2.
             </code>
             </example>
             <param name="edgelabels">The edge labels that are taken into account when counting the node degrees.</param>
             <returns>
             Returns the degree histogram as dictionary with the degrees as keys and the number of times a degree occurs as values.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.GetGraphDensity">
             <summary>
             This method returns the desity of the graph.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node n1 = new Node("Office");
             n1.Name= "Office of Louise";
             Node n2 = new Node("Office");
             n1.Name = "Office of Ruben";
             Node n3 = new Node("Corridor");
             List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3 };
            
             // Make edges
             Edge e1 = new Edge("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge e2 = new Edge("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge e3 = new Edge("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3 };
            
             // Construct graph
             Graph g = new Graph();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             double density = g.GetGraphDensity();
            
             Console.WriteLine("The density of the graph is " + density + ".");
             // The example displays the following output:
             //   The density of the graph is 1.
             </code>
             </example>
             <returns>
             Returns the density of the graph as a result of the formula 
             <code>2.0 * Edges.Count / (Nodes.Count * (Nodes.Count - 1.0))</code>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.ShortestPathLength(PlanGraphLibPy.The_graph.Node,PlanGraphLibPy.The_graph.Node,System.Collections.Generic.List{System.String})">
            <summary>
            This method finds the Dijkstra shortest path between two nodes. Only those edges with an edge label 
            present in <c>edgeLabelsToConsider</c> are taken into account.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Office");
            n1.Name= "Office of Louise";
            Node n2 = new Node("Office");
            n2.Name = "Office of Ruben";
            Node n3 = new Node("Corridor");
            n3.Name = "Back entrance";
            Node n4 = new Node("Corridor");
            n4.Name = "Front entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Reception area";
            Node n6 = new Node("Publicly accessible space");
            n6.Name = "Waiting room";
            Node n7 = new Node("Exterior");
            n7.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5, n6, n7 };
            
            // Make edges
            Edge e1 = new Edge("Door");
            e1.SetNodeStart(n1);
            e1.SetNodeEnd(n3);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n2);
            e2.SetNodeEnd(n3);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n6);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n2);
            e4.SetNodeEnd(n6);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n5);
            e5.SetNodeEnd(n6);
            Edge e6 = new Edge("Door");
            e6.SetNodeStart(n4);
            e6.SetNodeEnd(n5);
            Edge e7 = new Edge("Exterior door");
            e7.SetNodeStart(n3);
            e7.SetNodeEnd(n7);
            Edge e8 = new Edge("Exterior door");
            e8.SetNodeStart(n4);
            e8.SetNodeEnd(n7);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5, e6, e7, e8 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            int shortestPathLength = g.ShortestPathLength(n7, n1, g.EdgeLabelsCollection); // between office of Louise and the sidewalk
            
            Console.WriteLine("To go from the sidewalk to the office of Louise, we need to pass through " + shortestPathLength + " doors.");
            // The example displays the following output:
            //   To go from the sidewalk to the office of Louise, we need to pass through 2 doors.
            </code>
            </example>
            <param name="node1">The start as node.</param>
            <param name="node2">The finish as node.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when searching for the shortest path.</param>
            <returns>
            Returns the length of the shortest path.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph.AllPaths(PlanGraphLibPy.The_graph.Node,PlanGraphLibPy.The_graph.Node,System.Collections.Generic.List{System.String})">
            <summary>
            This method finds all valid paths between two nodes as a list of node sequences. A valid path in this case is a path 
            that does not pass through a node more than one time. Only those edges with an edge label present in 
            <c>edgeLabelsToConsider</c> are taken into account.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Office");
            n1.Name= "Office of Louise";
            Node n2 = new Node("Exterior");
            n2.Name = "Sidewalk";
            Node n3 = new Node("Corridor");
            n3.Name = "Back entrance";
            Node n4 = new Node("Corridor");
            n4.Name = "Front entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Reception area";
            Node n6 = new Node("Publicly accessible space");
            n6.Name = "Waiting room";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5, n6 };
            
            // Make edges
            Edge e1 = new Edge("Door");
            e1.SetNodeStart(n1);
            e1.SetNodeEnd(n3);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n6);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n5);
            e3.SetNodeEnd(n6);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n5);
            Edge e5 = new Edge("Exterior door");
            e5.SetNodeStart(n3);
            e5.SetNodeEnd(n2);
            Edge e6 = new Edge("Exterior door");
            e6.SetNodeStart(n4);
            e6.SetNodeEnd(n2);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5, e6 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            List&lt;List&lt;Node&gt;&gt; allPaths = g.AllPaths(n2, n1, g.EdgeLabelsCollection); // between office of Louise and the sidewalk
            
            int pathNr = 1;
            foreach (List&lt;Node&gt; path in allPaths)
            {
                Console.WriteLine("Path " + pathNr + " exists of the following space sequence:");
                foreach (Node node in path)
                {
                    Console.WriteLine("    " + node.Name);
                }
                pathNr++;
            }
            // The example displays the following output:
            //   Path 1 exists of the following space sequence:
            //       Sidewalk
            //       Back entrance
            //       Office of Louise
            //   Path 2 exists of the following space sequence:
            //       Sidewalk
            //       Front entrance
            //       Reception area
            //       Waiting room
            //       Office of Louise
            </code>
            </example>
            <param name="node1">The start as node.</param>
            <param name="node2">The finish as node.</param>
            <param name="edgeLabelsToConsider">The edge labels that are taken into account when searching for paths.</param>
            <returns>
            Returns a list of paths. A path is represented by an ordered list of nodes.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.The_graph.Node">
            <summary>
            Class <c>Node</c> constructs a node with its name and label.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node.Name">
            <summary>
            Property <c>Name</c> represents the name of the <c>Node</c> as a string.
            </summary>
            <example>For example:
            <code>
            Node n = new Node("Office");
            n.Name = "Office of Louise";
            Console.WriteLine(n.Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <value>
            Property <c>Name</c> represents the name of the <c>Node</c> as a string.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node.NodeLabel">
            <summary>
            Property <c>NodeLabel</c> represents the node label of the <c>Node</c> as a string.
            </summary>
            <example>For example:
            <code>
            Node n = new Node("Office");
            Console.WriteLine(n.NodeLabel);
            // The example displays the following output:
            //    office
            </code>
            </example>
            <value>
            Property <c>NodeLabel</c> represents the node label of the <c>Node</c> as a string.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node.GUID">
            <summary>
            Property <c>GUID</c> represents unique identifier of the <c>Node</c>.
            </summary>
            <example>For example:
            <code>
            Node n = new Node("Office");
            Console.WriteLine(n.GUID);
            // The example displays the following output:
            //    de123aea-5281-4a5a-b040-16eeb1658a9f
            </code>
            </example>
            <value>
            Property <c>GUID</c> represents unique identifier of the <c>Node</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node.dynamicProperties">
            <summary>
            Property <c>dynamicProperties</c> is a dynamic dictionary to add all sorts of properties to this <c>Node</c>.
            </summary>
            <example>For example:
            <code>
            Node n = new Node("Office");
            n.dynamicProperties["has_window"] = true;
            Console.WriteLine(n.dynamicProperties["has_window"]);
            // The example displays the following output:
            //    True
            </code>
            </example>
            <value>
            Property <c>dynamicProperties</c> is a dynamic dictionary to add all sorts of properties to this <c>Node</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node.DrawnCenter">
            <summary>
            Property <c>DrawnCenter</c> is used when the graph needs to be drawn. It is a <c>Point</c> with an x, y and z coordinate.
            </summary>
            <example>For example:
            <code>
            Node n = new Node("Office");
            Point center_of_room = new Point(0, 1, 2);
            n.DrawnCenter = center_of_room;
            </code>
            </example>
            <value>
            Property <c>DrawnCenter</c> is used when the graph needs to be drawn. It is a <c>Point</c> with an x, y and z coordinate.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node.AlignmentCost">
            <summary>
            Property <c>AlignmentCost</c> is used when two graphs are matched with each other. It is the resulting cost of aligning 
            one node to another.
            </summary>
            <value>
            Property <c>AlignmentCost</c> is used when two graphs are matched with each other. It is the resulting cost of aligning 
            one node to another.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Node.#ctor(System.String)">
            <summary>
            This constructor initializes a new <c>Node</c>.
            </summary>
            <example>For example:
            <code>
            Node n = new Node("Office");
            n.Name = "Office of Louise";
            Console.WriteLine(n.Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <param name="nodelabel">The node label of the <c>Node</c> as string.</param>
        </member>
        <member name="T:PlanGraphLibPy.The_graph.Edge_Space">
            <summary>
            Class <c>Edge_Space</c> constructs an edge which represents an adjacency between two
            spaces in a building, or an edge in a <c>Graph_Plan</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Edge_Space.NodeStart_Space">
            <summary>
            Property <c>NodeStart_Space</c> represents the starting space of the <c>Edge_Space</c>.
            </summary>
            <example>For example:
            <code>
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Corridor", 2, new Point(0, 2, 0));
            n2.Name = "Entrance";
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2 };
            
            Edge_Space e = new Edge_Space("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeStart().Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <value>
            Property <c>NodeStart_Space</c> represents the starting space of the <c>Edge_Space</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Edge_Space.NodeEnd_Space">
            <summary>
            Property <c>NodeEnd_Space</c> represents the space where the <c>Edge_Space</c> arrives.
            </summary>
            <example>For example:
            <code>
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Corridor", 2, new Point(0, 2, 0));
            n2.Name = "Entrance";
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2 };
            
            Edge_Space e = new Edge_Space("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeEnd().Name);
            // The example displays the following output:
            //    Entrance
            </code>
            </example>
            <value>
            Property <c>NodeEnd_Space</c> represents the space where the <c>Edge_Space</c> arrives.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge_Space.#ctor(System.String)">
            <summary>
            This constructor initializes a new <c>Edge_Space</c>.
            </summary>
            <example>For example:
            <code>
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Corridor", 2, new Point(0, 2, 0));
            n2.Name = "Entrance";
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2 };
            
            Edge_Space e = new Edge_Space("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            </code>
            </example>
            <param name="edgelabel">The label of the <c>Edge_Space</c> as a string.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge_Space.#ctor">
            <summary>
            This constructor initializes a new, empty <c>Edge_Space</c>.
            </summary>
            <example>For example:
            <code>
            Edge_Space e = new Edge_Space();
            </code>
            </example>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge_Space.SetNodeStart(PlanGraphLibPy.The_graph.Node_Space)">
            <summary>
            This method sets the space at the start of the <c>Edge_Space</c>.
            </summary>
            <example>For example:
            <code>
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Corridor", 2, new Point(0, 2, 0));
            n2.Name = "Entrance";
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2 };
            
            Edge_Space e = new Edge_Space("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeStart().Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <param name="node">The starting node of the <c>Edge_Space</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge_Space.GetNodeStart">
            <summary>
            This method gets the space at the start of the <c>Edge_Space</c>.
            </summary>
            <example>For example:
            <code>
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Corridor", 2, new Point(0, 2, 0));
            n2.Name = "Entrance";
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2 };
            
            Edge_Space e = new Edge_Space("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeStart().Name);
            // The example displays the following output:
            //    Office of Louise
            </code>
            </example>
            <returns>
            Returns the starting node of the <c>Edge_Space</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge_Space.SetNodeEnd(PlanGraphLibPy.The_graph.Node_Space)">
            <summary>
            This method sets the space where the <c>Edge_Space</c> arrives.
            </summary>
            <example>For example:
            <code>
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Corridor", 2, new Point(0, 2, 0));
            n2.Name = "Entrance";
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2 };
            
            Edge_Space e = new Edge_Space("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeEnd().Name);
            // The example displays the following output:
            //    Entrance
            </code>
            </example>
            <param name="node">The node where the <c>Edge_Space</c> arrives.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Edge_Space.GetNodeEnd">
            <summary>
            This method gets the space where the <c>Edge_Space</c> arrives.
            </summary>
            <example>For example:
            <code>
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Corridor", 2, new Point(0, 2, 0));
            n2.Name = "Entrance";
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2 };
            
            Edge_Space e = new Edge_Space("Door");
            e.SetNodeStart(n1);
            e.SetNodeEnd(n2);
            
            Console.WriteLine(e.GetNodeEnd().Name);
            // The example displays the following output:
            //    Entrance
            </code>
            </example>
            <returns>
            Returns the node where the <c>Edge_Space</c> arrives.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.The_graph.Graph_Plan">
            <summary>
            Class <c>Graph_Plan</c> constructs a graph which represents a plan with spaces as nodes
            and adjacencies between the spaces as edges.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph_Plan.Node_Spaces">
            <summary>
            Property <c>Node_Spaces</c> represents the list of spaces as nodes in this <c>Graph_Plan</c>.
            </summary>
            <value>
            Property <c>Node_Spaces</c> represents the list of spaces as nodes in this <c>Graph_Plan</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Graph_Plan.Edge_Spaces">
            <summary>
            Property <c>Edge_Spaces</c> represents the list of edges in this <c>Graph_Plan</c>.
            </summary>
            <value>
            Property <c>Edge_Spaces</c> represents the list of edges in this <c>Graph_Plan</c>.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.#ctor">
            <summary>
            This constructor initializes a new empty <c>Graph_Plan</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
            n2.Name = "Office of Ruben";
            Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Door");
            e1.SetNodeStart(n1);
            e1.SetNodeEnd(n3);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n2);
            e2.SetNodeEnd(n3);
            Edge_Space e3 = new Edge_Space("Wall");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n2);
            List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g = new Graph_Plan();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            </code>
            </example>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.AddNodes(System.Collections.Generic.List{PlanGraphLibPy.The_graph.Node_Space})">
             <summary>
             This method adds a list of spaces to the <c>Graph_Plan</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
             n1.Name = "Office of Louise";
             Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
             n2.Name = "Office of Ruben";
             Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
             List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
             
             // Make edges
             Edge_Space e1 = new Edge_Space("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge_Space e2 = new Edge_Space("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge_Space e3 = new Edge_Space("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
             
             // Construct graph
             Graph_Plan g = new Graph_Plan();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Node_Space node in g.GetNodes())
             {
                 Console.WriteLine(node.NodeLabel + ": " + node.Name);
             }
             // The example displays the following output:
             //    office: Office of Louise
             //    office: Office of Ruben
             //    corridor:
             </code>
             </example>
             <param name="nodes">The list of nodes that need to be added to the <c>Graph_Plan</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.GetNodes">
             <summary>
             This method returns the <c>Node_Spaces</c> of the <c>Graph_Plan</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
             n1.Name = "Office of Louise";
             Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
             n2.Name = "Office of Ruben";
             Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
             List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
             
             // Make edges
             Edge_Space e1 = new Edge_Space("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge_Space e2 = new Edge_Space("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge_Space e3 = new Edge_Space("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
             
             // Construct graph
             Graph_Plan g = new Graph_Plan();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Node_Space node in g.GetNodes())
             {
                 Console.WriteLine(node.NodeLabel + ": " + node.Name);
             }
             // The example displays the following output:
             //    office: Office of Louise
             //    office: Office of Ruben
             //    corridor:
             </code>
             </example>
             <returns>
             Returns all <c>Node_Spaces</c> of the <c>Graph_Plan</c>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.AddEdges(System.Collections.Generic.List{PlanGraphLibPy.The_graph.Edge_Space})">
             <summary>
             This method adds a list of edges to the <c>Graph_Plan</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
             n1.Name = "Office of Louise";
             Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
             n2.Name = "Office of Ruben";
             Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
             List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
             
             // Make edges
             Edge_Space e1 = new Edge_Space("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge_Space e2 = new Edge_Space("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge_Space e3 = new Edge_Space("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
             
             // Construct graph
             Graph_Plan g = new Graph_Plan();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Edge_Space edge in g.GetEdges())
             {
                 Console.WriteLine(edge.EdgeLabel);
             }
             // The example displays the following output:
             //    door
             //    door
             //    wall
             </code>
             </example>
             <param name="edges">The list of edges that need to be added to the <c>Graph_Plan</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.GetEdges">
             <summary>
             This method returns the <c>Edge_Spaces</c> of the <c>Graph_Plan</c>.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
             n1.Name = "Office of Louise";
             Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
             n2.Name = "Office of Ruben";
             Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
             List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
             
             // Make edges
             Edge_Space e1 = new Edge_Space("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge_Space e2 = new Edge_Space("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge_Space e3 = new Edge_Space("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
             
             // Construct graph
             Graph_Plan g = new Graph_Plan();
             g.AddNodes(nodes);
             g.AddEdges(edges);
            
             foreach(Edge_Space edge in g.GetEdges())
             {
                 Console.WriteLine(edge.EdgeLabel);
             }
             // The example displays the following output:
             //    door
             //    door
             //    wall
             </code>
             </example>
             <returns>
             Returns all <c>Edge_Spaces</c> of the <c>Graph_Plan</c>.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.GetNeighbours(PlanGraphLibPy.The_graph.Node_Space,System.String)">
             <summary>
             This method gets all neighbouring spaces of a predefined space. Only those edges with 
             the specified <c>edgelabel</c> are taken into account when searching for neighbours, all other 
             edges are ignored.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
             n1.Name = "Office of Louise";
             Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
             n2.Name = "Office of Ruben";
             Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
             List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
             
             // Make edges
             Edge_Space e1 = new Edge_Space("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge_Space e2 = new Edge_Space("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge_Space e3 = new Edge_Space("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
             
             // Construct graph
             Graph_Plan g = new Graph_Plan();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             List&lt;Node_Space&gt; neighbours = g.GetNeighbours(n1, "door");
            
             foreach(Node_Space neighbour in neighbours)
             {
                 Console.WriteLine(neighbour.NodeLabel + ": " + neighbour.Name);
             }
             // The example displays the following output:
             //    corridor:
             </code>
             </example>
             <param name="node">The space from which we want to know its neightbours.</param>
             <param name="edgeLabel">Only edges with this label are taken into account.</param>
             <returns>
             Returns all neighbours of the <c>node</c> as a list of nodes.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.GetNeighbours(PlanGraphLibPy.The_graph.Node_Space,System.Collections.Generic.List{System.String})">
             <summary>
             This method gets all neighbouring spaces of a predefined space. Only those edges with 
             an edge label present in <c>edgeLabels</c> are taken into account when searching for neighbours, 
             all other edges are ignored.
             </summary>
             <example>For example:
             <code>
             // Make nodes
             Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
             n1.Name = "Office of Louise";
             Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
             n2.Name = "Office of Ruben";
             Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
             List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
             
             // Make edges
             Edge_Space e1 = new Edge_Space("Door");
             e1.SetNodeStart(n1);
             e1.SetNodeEnd(n3);
             Edge_Space e2 = new Edge_Space("Door");
             e2.SetNodeStart(n2);
             e2.SetNodeEnd(n3);
             Edge_Space e3 = new Edge_Space("Wall");
             e3.SetNodeStart(n1);
             e3.SetNodeEnd(n2);
             List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
             
             // Construct graph
             Graph_Plan g = new Graph_Plan();
             g.AddNodes(nodes);
             g.AddEdges(edges);
             List&lt;Node_Space&gt; neighbours = g.GetNeighbours(n1, g.EdgeLabelsCollection);
            
             foreach(Node_Space neighbour in neighbours)
             {
                 Console.WriteLine(neighbour.NodeLabel + ": " + neighbour.Name);
             }
             // The example displays the following output:
             //    office: Office of Ruben
             //    corridor:
             </code>
             </example>
             <param name="node">The node from which we want to know its neightbours.</param>
             <param name="edgeLabels">Only edges with these labels are taken into account.</param>
             <returns>
             Returns all neighbours of the space as a list of nodes.
             </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Graph_Plan.GetGraphAsCsv(System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            This method returns the properties of the nodes and the edges of the <c>Graph_Plan</c> as 
            comma-separated values.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node_Space n1 = new Node_Space("Office", 12.5, new Point(2, 2, 0));
            n1.Name = "Office of Louise";
            Node_Space n2 = new Node_Space("Office", 12.5, new Point(2, 6, 0));
            n2.Name = "Office of Ruben";
            Node_Space n3 = new Node_Space("Corridor", 2, new Point(0, 4, 0));
            List&lt;Node_Space&gt; nodes = new List&lt;Node_Space&gt;() { n1, n2, n3 };
            
            // Make edges
            Edge_Space e1 = new Edge_Space("Door");
            e1.SetNodeStart(n1);
            e1.SetNodeEnd(n3);
            Edge_Space e2 = new Edge_Space("Door");
            e2.SetNodeStart(n2);
            e2.SetNodeEnd(n3);
            Edge_Space e3 = new Edge_Space("Wall");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n2);
            List&lt;Edge_Space&gt; edges = new List&lt;Edge_Space&gt;() { e1, e2, e3 };
            
            // Construct graph
            Graph_Plan g = new Graph_Plan();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            List&lt;string&gt; nodeinfo = new List&lt;string&gt;();
            List&lt;string&gt; edgeinfo = new List&lt;string&gt;();
            g.GetGraphAsCsv(out nodeinfo, out edgeinfo);
            
            foreach (string info in nodeinfo)
            {
                Console.WriteLine(info);
            }
            Console.WriteLine(" ");
            foreach (string info in edgeinfo)
            {
                Console.WriteLine(info);
            }
            // The example displays the following output:
            //    ID,Label,IsOutsideWorld,Area,Name,X,Y,Z
            //    0,office,false,12,5,Office of Louise,2,2,0
            //    1,office,false,12,5,Office of Ruben,2,6,0
            //    2,corridor,false,2,,0,4,0
            //    
            //    ID,Label,Source,Target
            //    0,door,0,2
            //    1,door,1,2
            //    2,wall,0,1
            </code>
            </example>
            <param name="csvNodes">The node properties structured as comma-separated values.</param>
            <param name="csvEdges">The edge properties structured as comma-separated values.</param>
        </member>
        <member name="T:PlanGraphLibPy.The_graph.Node_Space">
            <summary>
            Class <c>Node_Space</c> constructs a node which represents a space in a building, or
            a node in a <c>Graph_Plan</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node_Space.Area">
            <summary>
            Property <c>Area</c> represents the area of the space.
            </summary>
            <example>For example:
            <code>
            // Create the boundary
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline boundary = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            
            // Create the node
            Node_Space n = new Node_Space("Office", boundary);
            Console.WriteLine(n.Area);
            // The example displays the following output:
            //    25
            </code>
            </example>
            <value>
            Property <c>Area</c> represents the area of the space.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node_Space.Center">
            <summary>
            Property <c>Center</c> represents the center of gravity of the space boundary.
            </summary>
            <example>For example:
            <code>
            // Create the boundary
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline boundary = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            
            // Create the node
            Node_Space n = new Node_Space("Office", boundary);
            Console.WriteLine(n.Center.X + " - " + n.Center.Y + " - " + n.Center.Z);
            // The example displays the following output:
            //    2,5 - 2,5 - 0
            </code>
            </example>
            <value>
            Property <c>Center</c> represents the center of gravity of the space.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node_Space.Boundary">
            <summary>
            Property <c>Boundary</c> represents the interior space boundary at floor level.
            </summary>
            <example>For example:
            <code>
            // Create the boundary
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline boundary = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            
            // Create the node
            Node_Space n = new Node_Space("Office", boundary);
            </code>
            </example>
            <value>
            Property <c>Boundary</c> represents the interior space boundary at floor level.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_graph.Node_Space.IsOutsideWorld">
            <summary>
            Property <c>IsOutsideWorld</c> makes it possible to link other spaces to the ouside world, 
            f.ex. the road. A node with this property set to true does not require all information to 
            be filled in and can thus remain abstract.
            </summary>
            <example>For example:
            <code>
            Node_Space n = new Node_Space(true);
            Console.WriteLine(n.IsOutsideWorld);
            // The example displays the following output:
            //    True
            </code>
            </example>
            <value>
            Property <c>IsOutsideWorld</c> makes it possible to link other spaces to the ouside world, 
            f.ex. the road. A node with this property set to true does not require all information to 
            be filled in and can thus remain abstract.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Node_Space.#ctor(System.String,System.Double,PlanGraphLibPy.Geometry.Point)">
            <summary>
            This constructor initializes a new <c>Node_Space</c>.
            </summary>
            <example>For example:
            <code>
            Node_Space n = new Node_Space("Office", 12.5, new Point(2, 3, 0));
            </code>
            </example>
            <param name="nodelabel">The node label of the <c>Node_Space</c> as string.</param>
            <param name="area">The area of the space.</param>
            <param name="center">The center of gravity of the space boundary.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Node_Space.#ctor(System.String,PlanGraphLibPy.Geometry.Polyline)">
            <summary>
            This constructor initializes a new <c>Node_Space</c>.
            </summary>
            <example>For example:
            <code>
            // Create the boundary
            Point p1 = new Point(0, 0, 0);
            Point p2 = new Point(0, 5, 0);
            Point p3 = new Point(5, 5, 0);
            Point p4 = new Point(5, 0, 0);
            Polyline boundary = new Polyline(new List&lt;Point&gt; { p1, p2, p3, p4, p1 });
            
            // Create the node
            Node_Space n = new Node_Space("Office", boundary);
            </code>
            </example>
            <param name="nodelabel">The node label of the <c>Node_Space</c> as string.</param>
            <param name="boundary">The interior space boundary at floor level.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Node_Space.#ctor(System.Boolean)">
            <summary>
            This constructor initializes a new <c>Node_Space</c>.
            </summary>
            <example>For example:
            <code>
            Node_Space n = new Node_Space(true);
            Console.WriteLine(n.IsOutsideWorld);
            // The example displays the following output:
            //    True
            </code>
            </example>
            <param name="isOutsideWorld">A node with this property set to true does not require all 
            information to be filled in and can thus remain abstract. A node that represents the outside 
            world is for example the road for a house or the common corridor for an appartment. </param>
        </member>
        <member name="M:PlanGraphLibPy.The_graph.Node_Space.#ctor">
            <summary>
            This constructor initializes a new, empty <c>Node_Space</c>.
            </summary>
            <example>For example:
            <code>
            Node_Space n = new Node_Space();
            </code>
            </example>
        </member>
        <member name="T:PlanGraphLibPy.The_tree.Tree">
            <summary>
            Class <c>Tree</c> constructs a new representation of a <c>Graph</c> with a root node and its branches.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.Tree.Root">
            <summary>
            Property <c>Root</c> represents the root of this <c>Tree</c> as <c>TreeNode</c>.
            </summary>
            <value>
            Property <c>Root</c> represents the root of this <c>Tree</c> as <c>TreeNode</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.Tree.Depth">
            <summary>
            Property <c>Depth</c> represents the number of levels following the root, excl. root level.
            </summary>
            <value>
            Property <c>Depth</c> represents the number of levels following the root, excl. root level.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.Tree.TreeNodesByLevel">
            <summary>
            Property <c>TreeNodesByLevel</c> is a dictionary with the levels as keys and the treenodes on that level as values.
            </summary>
            <value>
            Property <c>TreeNodesByLevel</c> is a dictionary with the levels as keys and the treenodes on that level as values.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.Tree.EdgeLabelsToConsider">
            <summary>
            Property <c>EdgeLabelsToConsider</c> represents a list of edge labels that are taken into account to construct 
            this <c>Tree</c>.
            </summary>
            <value>
            Property <c>EdgeLabelsToConsider</c> represents a list of edge labels that are taken into account to construct 
            this <c>Tree</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.Tree.OriginalGraph">
            <summary>
            Property <c>OriginalGraph</c> represents the <c>Graph</c> from which this <c>Tree</c> was made.
            </summary>
            <value>
            Property <c>OriginalGraph</c> represents the <c>Graph</c> from which this <c>Tree</c> was made.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.The_tree.Tree.#ctor(PlanGraphLibPy.The_graph.Graph,PlanGraphLibPy.The_graph.Node,System.Collections.Generic.List{System.String},System.Int32,System.Boolean)">
            <summary>
            This constructor initializes a new <c>Tree</c> from a <c>Graph</c>.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct tree
            Tree t = new Tree(g, n5, g.EdgeLabelsCollection, 3, false);
            for (int i = 0; i &lt;= 3; i++)
            {
            	Console.WriteLine("Level " + i);
            	foreach (TreeNode node in t.TreeNodesByLevel[i])
            	{
            		Console.WriteLine("    " + node.GraphNode.Name);
            	}
            }
            // The example displays the following output:
            //    Level 0
            //        Sidewalk
            //    Level 1
            //        Front entrance
            //    Level 2
            //        Left room
            //        Right room
            //    Level 3
            //        Back entrance
            </code>
            </example>
            <param name="graph">The <c>Graph</c> from which this <c>Tree</c> will be made.</param>
            <param name="root">The root of this <c>Tree</c> as <c>Node</c>.</param>
            <param name="edgeLabelsToConsider">The list of edge labels that are taken into account to construct 
            this <c>Tree</c>.</param>
            <param name="depth">The depth of the <c>Tree</c>.</param>
            <param name="NED">True if a <c>Node</c> from the <c>Graph</c> may occur multiple times in the <c>Tree</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_tree.Tree.Clone">
            <summary>
            This method returns a clone of this <c>Tree</c>.
            </summary>
            <returns>
            Returns a clone of this <c>Tree</c>.
            </returns>
        </member>
        <member name="M:PlanGraphLibPy.The_tree.Tree.EditDistance(PlanGraphLibPy.The_tree.Tree)">
            <summary>
            This method calculates the edit distance from this <c>Tree</c> to another <c>Tree</c>.
            
            The edit distance is based on the calculation explained in this article:
            Zhu H, Meng X, Kollios G. NED: An Inter-Graph Node Metric Based On Edit Distance. arXiv: Databases. 2016:1 - 27.
            DOI: https://doi.org/10.48550/arXiv.1602.02358.
            </summary>
            <example>For example:
            <code>
            // Make nodes
            Node n1 = new Node("Entrance");
            n1.Name = "Front entrance";
            Node n2 = new Node("Room");
            n2.Name = "Left room";
            Node n3 = new Node("Room");
            n3.Name = "Right room";
            Node n4 = new Node("Entrance");
            n4.Name = "Back entrance";
            Node n5 = new Node("Publicly accessible space");
            n5.Name = "Sidewalk";
            List&lt;Node&gt; nodes = new List&lt;Node&gt;() { n1, n2, n3, n4, n5 };
            
            // Make edges
            Edge e1 = new Edge("Exterior door");
            e1.SetNodeStart(n5);
            e1.SetNodeEnd(n1);
            Edge e2 = new Edge("Door");
            e2.SetNodeStart(n1);
            e2.SetNodeEnd(n2);
            Edge e3 = new Edge("Door");
            e3.SetNodeStart(n1);
            e3.SetNodeEnd(n3);
            Edge e4 = new Edge("Door");
            e4.SetNodeStart(n4);
            e4.SetNodeEnd(n2);
            Edge e5 = new Edge("Door");
            e5.SetNodeStart(n4);
            e5.SetNodeEnd(n3);
            List&lt;Edge&gt; edges = new List&lt;Edge&gt;() { e1, e2, e3, e4, e5 };
            
            // Construct graph
            Graph g = new Graph();
            g.AddNodes(nodes);
            g.AddEdges(edges);
            
            // Construct tree
            Tree t1 = new Tree(g, n5, g.EdgeLabelsCollection, 3, false);
            Tree t2 = new Tree(g, n2, g.EdgeLabelsCollection, 3, false);
            Tree t3 = new Tree(g, n3, g.EdgeLabelsCollection, 3, false);
            
            Console.WriteLine(t1.EditDistance(t2));
            Console.WriteLine(t2.EditDistance(t3));
            // The example displays the following output:
            //    3
            //    0
            </code>
            </example>
            <param name="otherTree">The other <c>Tree</c>.</param>
            <returns>
            Returns edit distance between the two trees.
            </returns>
        </member>
        <member name="T:PlanGraphLibPy.The_tree.TreeNode">
            <summary>
            Class <c>TreeNode</c> represents a node in a <c>Tree</c>.
            </summary>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.TreeNode.GraphNode">
            <summary>
            Property <c>GraphNode</c> represents the <c>Node</c> from which this <c>TreeNode</c> was made.
            </summary>
            <value>
            Property <c>GraphNode</c> represents the <c>Node</c> from which this <c>TreeNode</c> was made.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.TreeNode.Parent">
            <summary>
            Property <c>Parent</c> represents the <c>TreeNode</c> which is the origin of this branch.
            </summary>
            <value>
            Property <c>Parent</c> represents the <c>TreeNode</c> which is the origin of this branch.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.TreeNode.Children">
            <summary>
            Property <c>Children</c> represents a list of treenodes from which this <c>TreeNode</c> is the parent.
            </summary>
            <value>
            Property <c>Children</c> represents a list of treenodes from which this <c>TreeNode</c> is the parent.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.TreeNode.Siblings">
            <summary>
            Property <c>Siblings</c> represents a list of treenodes on the same level as this <c>TreeNode</c>.
            </summary>
            <value>
            Property <c>Siblings</c> represents a list of treenodes on the same level as this <c>TreeNode</c>.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.TreeNode.isCopy">
            <summary>
            Property <c>isCopy</c> is true if this <c>TreeNode</c> represents a <c>Node</c> that is already present in the tree.
            Only when NED is set to true in the <c>Tree</c>, a copy can occur.
            </summary>
            <value>
            Property <c>isCopy</c> is true if this <c>TreeNode</c> represents a <c>Node</c> that is already present in the tree.
            Only when NED is set to true in the <c>Tree</c>, a copy can occur.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.TreeNode.CanonizationLabel">
            <summary>
            Property <c>CanonizationLabel</c> is used in the calculation of the edit distance between two trees.
            It represents a unique label based on the tree structure of this <c>TreeNode</c> as if this node was a root.
            </summary>
            <value>
            Property <c>CanonizationLabel</c> is used in the calculation of the edit distance between two trees.
            It represents a unique label based on the tree structure of this <c>TreeNode</c> as if this node was a root.
            </value>
        </member>
        <member name="F:PlanGraphLibPy.The_tree.TreeNode.CanonizationLabelsChildren">
            <summary>
            Property <c>CanonizationLabelsChildren</c> is used in the calculation of the edit distance between two trees.
            It is a list of the canonization labels of the children of this <c>TreeNode</c>.
            </summary>
            <value>
            Property <c>CanonizationLabelsChildren</c> is used in the calculation of the edit distance between two trees.
            It is a list of the canonization labels of the children of this <c>TreeNode</c>.
            </value>
        </member>
        <member name="M:PlanGraphLibPy.The_tree.TreeNode.#ctor(PlanGraphLibPy.The_graph.Node,PlanGraphLibPy.The_tree.TreeNode)">
            <summary>
            This constructor initializes a new <c>TreeNode</c>.
            </summary>
            <param name="node">The <c>Node</c> from which this <c>TreeNode</c> will be made.</param>
            <param name="parent">The parent of this <c>TreeNode</c>.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_tree.TreeNode.#ctor">
            <summary>
            This constructor initializes a new, empty <c>TreeNode</c>.
            </summary>
        </member>
        <member name="M:PlanGraphLibPy.The_tree.TreeNode.AddChild(PlanGraphLibPy.The_tree.TreeNode)">
            <summary>
            This method adds a <c>TreeNode</c> to the list of children.
            </summary>
            <param name="child">The child that needs to be added.</param>
        </member>
        <member name="M:PlanGraphLibPy.The_tree.TreeNode.AddSibling(PlanGraphLibPy.The_tree.TreeNode)">
            <summary>
            This method adds a <c>TreeNode</c> to the list of siblings.
            </summary>
            <param name="sibling">The sibling that needs to be added.</param>
        </member>
    </members>
</doc>
